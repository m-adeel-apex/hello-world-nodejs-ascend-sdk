"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TradeBooking = void 0;
const tradeBookingCancelExecution_js_1 = require("../funcs/tradeBookingCancelExecution.js");
const tradeBookingCancelTrade_js_1 = require("../funcs/tradeBookingCancelTrade.js");
const tradeBookingCompleteTrade_js_1 = require("../funcs/tradeBookingCompleteTrade.js");
const tradeBookingCreateExecution_js_1 = require("../funcs/tradeBookingCreateExecution.js");
const tradeBookingCreateTrade_js_1 = require("../funcs/tradeBookingCreateTrade.js");
const tradeBookingGetExecution_js_1 = require("../funcs/tradeBookingGetExecution.js");
const tradeBookingGetTrade_js_1 = require("../funcs/tradeBookingGetTrade.js");
const tradeBookingRebookExecution_js_1 = require("../funcs/tradeBookingRebookExecution.js");
const tradeBookingRebookTrade_js_1 = require("../funcs/tradeBookingRebookTrade.js");
const sdks_js_1 = require("../lib/sdks.js");
const fp_js_1 = require("../types/fp.js");
class TradeBooking extends sdks_js_1.ClientSDK {
    /**
     * Create Trade
     *
     * @remarks
     * Creates a trade with one or more executions. Combination of (account_id, client_order_id, and the process_date (determined by Booking service)) determines the uniqueness of the trade.
     *
     *  Upon successful submission, returns the created trade and its details including Booking service enriched details.
     */
    async createTrade(tradeCreate, accountId, options) {
        return (0, fp_js_1.unwrapAsync)((0, tradeBookingCreateTrade_js_1.tradeBookingCreateTrade)(this, tradeCreate, accountId, options));
    }
    /**
     * Get Trade
     *
     * @remarks
     * Gets a trade and all executions by trade_id.
     *
     *  Upon successful submission, returns the trade details and all the execution by trade_id.
     */
    async getTrade(accountId, tradeId, options) {
        return (0, fp_js_1.unwrapAsync)((0, tradeBookingGetTrade_js_1.tradeBookingGetTrade)(this, accountId, tradeId, options));
    }
    /**
     * Complete Trade
     *
     * @remarks
     * Complete a Trade by closing and generating any fees and withholdings if necessary. Once this endpoint returns an OK, the combination of details that generated the Trade (account_id, client_order_id, and the process_date) cannot be reused.
     *
     *  Upon successful submission, returns completed trade details and all the executions. Trades that are left open will be automatically closed nightly before Ledger's EOD.
     */
    async completeTrade(completeTradeRequestCreate, accountId, tradeId, options) {
        return (0, fp_js_1.unwrapAsync)((0, tradeBookingCompleteTrade_js_1.tradeBookingCompleteTrade)(this, completeTradeRequestCreate, accountId, tradeId, options));
    }
    /**
     * Cancel Trade
     *
     * @remarks
     * Cancel a trade and all the executions using the original trade_id. CancelTrade will either cancel everything, or nothing at all if a failure occurs.
     *
     *  Upon successful submission, returns an empty response.
     */
    async cancelTrade(cancelTradeRequestCreate, accountId, tradeId, options) {
        return (0, fp_js_1.unwrapAsync)((0, tradeBookingCancelTrade_js_1.tradeBookingCancelTrade)(this, cancelTradeRequestCreate, accountId, tradeId, options));
    }
    /**
     * Rebook Trade
     *
     * @remarks
     * Rebook a trade by the original trade_id. The entire original trade's executions are rebooked using the executions provided in the request. If applicable, fees and backup withholdings will be re-calculated.
     *
     *  Upon successful submission, returns the rebooked trade details and all the executions.
     */
    async rebookTrade(rebookTradeRequestCreate, accountId, tradeId, options) {
        return (0, fp_js_1.unwrapAsync)((0, tradeBookingRebookTrade_js_1.tradeBookingRebookTrade)(this, rebookTradeRequestCreate, accountId, tradeId, options));
    }
    /**
     * Create Execution
     *
     * @remarks
     * Create a new execution under an existing trade that is open.
     *
     *  Upon successful submission, returns the created execution and its details.
     */
    async createExecution(executionCreate, accountId, tradeId, options) {
        return (0, fp_js_1.unwrapAsync)((0, tradeBookingCreateExecution_js_1.tradeBookingCreateExecution)(this, executionCreate, accountId, tradeId, options));
    }
    /**
     * Get Execution
     *
     * @remarks
     * Gets an execution by execution_id.
     *
     *  Upon successful submission, returns the execution details by execution_id.
     */
    async getExecution(accountId, tradeId, executionId, options) {
        return (0, fp_js_1.unwrapAsync)((0, tradeBookingGetExecution_js_1.tradeBookingGetExecution)(this, accountId, tradeId, executionId, options));
    }
    /**
     * Cancel Execution
     *
     * @remarks
     * Cancel an execution using the original execution_id. If applicable, fees and backup withholdings will be re-calculated.
     *
     *  Upon successful submission, returns the execution that was canceled.
     */
    async cancelExecution(cancelExecutionRequestCreate, accountId, tradeId, executionId, options) {
        return (0, fp_js_1.unwrapAsync)((0, tradeBookingCancelExecution_js_1.tradeBookingCancelExecution)(this, cancelExecutionRequestCreate, accountId, tradeId, executionId, options));
    }
    /**
     * Rebook Execution
     *
     * @remarks
     * Rebook an execution by the original execution_id. If applicable, fees and backup withholdings will be re-calculated.
     *
     *  Upon successful submission, returns the rebooked execution details.
     */
    async rebookExecution(rebookExecutionRequestCreate, accountId, tradeId, executionId, options) {
        return (0, fp_js_1.unwrapAsync)((0, tradeBookingRebookExecution_js_1.tradeBookingRebookExecution)(this, rebookExecutionRequestCreate, accountId, tradeId, executionId, options));
    }
}
exports.TradeBooking = TradeBooking;
//# sourceMappingURL=tradebooking.js.map