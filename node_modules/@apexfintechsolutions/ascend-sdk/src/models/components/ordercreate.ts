/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import {
  catchUnrecognizedEnum,
  OpenEnum,
  Unrecognized,
} from "../../types/enums.js";
import {
  CommissionCreate,
  CommissionCreate$inboundSchema,
  CommissionCreate$Outbound,
  CommissionCreate$outboundSchema,
} from "./commissioncreate.js";
import {
  DateCreate,
  DateCreate$inboundSchema,
  DateCreate$Outbound,
  DateCreate$outboundSchema,
} from "./datecreate.js";
import {
  DecimalCreate,
  DecimalCreate$inboundSchema,
  DecimalCreate$Outbound,
  DecimalCreate$outboundSchema,
} from "./decimalcreate.js";
import {
  FeeCreate,
  FeeCreate$inboundSchema,
  FeeCreate$Outbound,
  FeeCreate$outboundSchema,
} from "./feecreate.js";
import {
  LetterOfIntentCreate,
  LetterOfIntentCreate$inboundSchema,
  LetterOfIntentCreate$Outbound,
  LetterOfIntentCreate$outboundSchema,
} from "./letterofintentcreate.js";
import {
  LimitPriceCreate,
  LimitPriceCreate$inboundSchema,
  LimitPriceCreate$Outbound,
  LimitPriceCreate$outboundSchema,
} from "./limitpricecreate.js";
import {
  RightsOfAccumulationCreate,
  RightsOfAccumulationCreate$inboundSchema,
  RightsOfAccumulationCreate$Outbound,
  RightsOfAccumulationCreate$outboundSchema,
} from "./rightsofaccumulationcreate.js";
import {
  StopPriceCreate,
  StopPriceCreate$inboundSchema,
  StopPriceCreate$Outbound,
  StopPriceCreate$outboundSchema,
} from "./stoppricecreate.js";

/**
 * The type of the asset in this order, which must be one of the following:
 *
 * @remarks
 *  EQUITY, MUTUAL_FUND, and FIXED_INCOME.
 */
export enum AssetType {
  Equity = "EQUITY",
  FixedIncome = "FIXED_INCOME",
  MutualFund = "MUTUAL_FUND",
}
/**
 * The type of the asset in this order, which must be one of the following:
 *
 * @remarks
 *  EQUITY, MUTUAL_FUND, and FIXED_INCOME.
 */
export type AssetTypeOpen = OpenEnum<typeof AssetType>;

/**
 * Defaults to "AGENCY" if not specified. For Equities: Only "AGENCY" is allowed. For Mutual Funds: Only "AGENCY" is allowed. For Fixed Income: Either "AGENCY" or "PRINCIPAL" are allowed.
 */
export enum BrokerCapacity {
  BrokerCapacityUnspecified = "BROKER_CAPACITY_UNSPECIFIED",
  Agency = "AGENCY",
  Principal = "PRINCIPAL",
}
/**
 * Defaults to "AGENCY" if not specified. For Equities: Only "AGENCY" is allowed. For Mutual Funds: Only "AGENCY" is allowed. For Fixed Income: Either "AGENCY" or "PRINCIPAL" are allowed.
 */
export type BrokerCapacityOpen = OpenEnum<typeof BrokerCapacity>;

/**
 * The identifier type of the asset being ordered. For Equities: only SYMBOL is supported For Mutual Funds: only SYMBOL and CUSIP are supported For Fixed Income: only CUSIP and ISIN are supported
 */
export enum IdentifierType {
  Symbol = "SYMBOL",
  Cusip = "CUSIP",
  Isin = "ISIN",
}
/**
 * The identifier type of the asset being ordered. For Equities: only SYMBOL is supported For Mutual Funds: only SYMBOL and CUSIP are supported For Fixed Income: only CUSIP and ISIN are supported
 */
export type IdentifierTypeOpen = OpenEnum<typeof IdentifierType>;

/**
 * The execution type of this order. For Equities: MARKET, LIMIT, or STOP are supported. For Mutual Funds: only MARKET is supported. For Fixed Income: only LIMIT is supported.
 */
export enum OrderType {
  OrderTypeUnspecified = "ORDER_TYPE_UNSPECIFIED",
  Limit = "LIMIT",
  Market = "MARKET",
  Stop = "STOP",
}
/**
 * The execution type of this order. For Equities: MARKET, LIMIT, or STOP are supported. For Mutual Funds: only MARKET is supported. For Fixed Income: only LIMIT is supported.
 */
export type OrderTypeOpen = OpenEnum<typeof OrderType>;

/**
 * The side of this order.
 */
export enum Side {
  SideUnspecified = "SIDE_UNSPECIFIED",
  Buy = "BUY",
  Sell = "SELL",
}
/**
 * The side of this order.
 */
export type SideOpen = OpenEnum<typeof Side>;

export enum SpecialReportingInstructions {
  SpecialReportingInstructionsUnspecified =
    "SPECIAL_REPORTING_INSTRUCTIONS_UNSPECIFIED",
  CustomerDirected = "CUSTOMER_DIRECTED",
  WithDividend = "WITH_DIVIDEND",
  WithRights = "WITH_RIGHTS",
  DiscretionExercised = "DISCRETION_EXERCISED",
  DiscretionNotExercised = "DISCRETION_NOT_EXERCISED",
  BrokerDealerOrder = "BROKER_DEALER_ORDER",
  FullyRegistered = "FULLY_REGISTERED",
  OddlotDiffOnRequest = "ODDLOT_DIFF_ON_REQUEST",
  ProspectusEnclosed = "PROSPECTUS_ENCLOSED",
  ProspectusSeparateMail = "PROSPECTUS_SEPARATE_MAIL",
  Solicited = "SOLICITED",
  Unsolicited = "UNSOLICITED",
  XDividend = "X_DIVIDEND",
  ActingAsPrincipal = "ACTING_AS_PRINCIPAL",
  AveragePrice = "AVERAGE_PRICE",
  BrokerLiquidation = "BROKER_LIQUIDATION",
  InternetOrder = "INTERNET_ORDER",
  MarginSellout = "MARGIN_SELLOUT",
  NegativeNetProceed = "NEGATIVE_NET_PROCEED",
  RisklessPrincipal = "RISKLESS_PRINCIPAL",
  ThirdMarket = "THIRD_MARKET",
  SuppressTraceReporting = "SUPPRESS_TRACE_REPORTING",
  WhenDistributed = "WHEN_DISTRIBUTED",
}
export type SpecialReportingInstructionsOpen = OpenEnum<
  typeof SpecialReportingInstructions
>;

/**
 * Must be the value "DAY". Regulatory requirements dictate that the system capture the intended time_in_force, which is why this a mandatory field.
 */
export enum TimeInForce {
  TimeInForceUnspecified = "TIME_IN_FORCE_UNSPECIFIED",
  Day = "DAY",
}
/**
 * Must be the value "DAY". Regulatory requirements dictate that the system capture the intended time_in_force, which is why this a mandatory field.
 */
export type TimeInForceOpen = OpenEnum<typeof TimeInForce>;

/**
 * The message describing an order
 */
export type OrderCreate = {
  /**
   * The type of the asset in this order, which must be one of the following:
   *
   * @remarks
   *  EQUITY, MUTUAL_FUND, and FIXED_INCOME.
   */
  assetType: AssetTypeOpen;
  /**
   * Defaults to "AGENCY" if not specified. For Equities: Only "AGENCY" is allowed. For Mutual Funds: Only "AGENCY" is allowed. For Fixed Income: Either "AGENCY" or "PRINCIPAL" are allowed.
   */
  brokerCapacity?: BrokerCapacityOpen | undefined;
  /**
   * User-supplied unique order ID. Cannot be more than 40 characters long.
   */
  clientOrderId: string;
  /**
   * Required for Equity Orders for any client who is having Apex do CAT reporting on their behalf. A value may be provided for non-Equity orders, and will be remembered, but valid timestamps will have no impact on how they are processed.
   */
  clientReceivedTime?: Date | null | undefined;
  /**
   * A custom commission applied to an order
   */
  commission?: CommissionCreate | undefined;
  /**
   * Defaults to "USD". Only "USD" is supported. Full list of currency codes is defined at: https://en.wikipedia.org/wiki/ISO_4217
   */
  currencyCode?: string | undefined;
  /**
   * Fees that will be applied to this order. Only the BROKER_FEE type is supported.
   */
  fees?: Array<FeeCreate> | undefined;
  /**
   * Identifier of the asset (of the type specified in `identifier_type`).
   */
  identifier: string;
  /**
   * A string attribute denoting the country of issuance or where the asset is trading. Only available for Mutual Fund orders. Defaults to US, when trading non US mutual funds this field must be provided Complies with ISO-3166 Alpha-2 Codes
   */
  identifierIssuingRegionCode?: string | undefined;
  /**
   * The identifier type of the asset being ordered. For Equities: only SYMBOL is supported For Mutual Funds: only SYMBOL and CUSIP are supported For Fixed Income: only CUSIP and ISIN are supported
   */
  identifierType: IdentifierTypeOpen;
  /**
   * Letter of Intent (LOI). An LOI allows investors to receive sales charge discounts based on a commitment to buy a specified monetary amount of shares over a period of time, usually 13 months.
   */
  letterOfIntent?: LetterOfIntentCreate | undefined;
  /**
   * A limit price definition
   */
  limitPrice?: LimitPriceCreate | undefined;
  /**
   * A representation of a decimal value, such as 2.5. Clients may convert values into language-native decimal formats, such as Java's [BigDecimal][] or Python's [decimal.Decimal][].
   *
   * @remarks
   *
   *  [BigDecimal]:
   *  https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/math/BigDecimal.html
   *  [decimal.Decimal]: https://docs.python.org/3/library/decimal.html
   */
  maxSellQuantity?: DecimalCreate | undefined;
  /**
   * A representation of a decimal value, such as 2.5. Clients may convert values into language-native decimal formats, such as Java's [BigDecimal][] or Python's [decimal.Decimal][].
   *
   * @remarks
   *
   *  [BigDecimal]:
   *  https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/math/BigDecimal.html
   *  [decimal.Decimal]: https://docs.python.org/3/library/decimal.html
   */
  notionalValue?: DecimalCreate | undefined;
  /**
   * Represents a whole or partial calendar date, such as a birthday. The time of day and time zone are either specified elsewhere or are insignificant. The date is relative to the Gregorian Calendar. This can represent one of the following:
   *
   * @remarks
   *
   *  * A full date, with non-zero year, month, and day values * A month and day value, with a zero year, such as an anniversary * A year on its own, with zero month and day values * A year and month value, with a zero day, such as a credit card expiration date
   *
   *  Related types are [google.type.TimeOfDay][google.type.TimeOfDay] and `google.protobuf.Timestamp`.
   */
  orderDate: DateCreate;
  /**
   * The execution type of this order. For Equities: MARKET, LIMIT, or STOP are supported. For Mutual Funds: only MARKET is supported. For Fixed Income: only LIMIT is supported.
   */
  orderType: OrderTypeOpen;
  /**
   * A representation of a decimal value, such as 2.5. Clients may convert values into language-native decimal formats, such as Java's [BigDecimal][] or Python's [decimal.Decimal][].
   *
   * @remarks
   *
   *  [BigDecimal]:
   *  https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/math/BigDecimal.html
   *  [decimal.Decimal]: https://docs.python.org/3/library/decimal.html
   */
  quantity?: DecimalCreate | undefined;
  /**
   * Rights of Accumulation (ROA). An ROA allows an investor to aggregate their own fund shares with the holdings of certain related parties toward achieving the investment thresholds at which sales charge discounts become available.
   */
  rightsOfAccumulation?: RightsOfAccumulationCreate | undefined;
  /**
   * The side of this order.
   */
  side: SideOpen;
  /**
   * Special Reporting Instructions to be applied to this order. Can include multiple Instructions.
   */
  specialReportingInstructions?:
    | Array<SpecialReportingInstructionsOpen>
    | undefined;
  /**
   * A stop price definition
   */
  stopPrice?: StopPriceCreate | undefined;
  /**
   * Must be the value "DAY". Regulatory requirements dictate that the system capture the intended time_in_force, which is why this a mandatory field.
   */
  timeInForce: TimeInForceOpen;
};

/** @internal */
export const AssetType$inboundSchema: z.ZodType<
  AssetTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(AssetType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const AssetType$outboundSchema: z.ZodType<
  AssetTypeOpen,
  z.ZodTypeDef,
  AssetTypeOpen
> = z.union([
  z.nativeEnum(AssetType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AssetType$ {
  /** @deprecated use `AssetType$inboundSchema` instead. */
  export const inboundSchema = AssetType$inboundSchema;
  /** @deprecated use `AssetType$outboundSchema` instead. */
  export const outboundSchema = AssetType$outboundSchema;
}

/** @internal */
export const BrokerCapacity$inboundSchema: z.ZodType<
  BrokerCapacityOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(BrokerCapacity),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const BrokerCapacity$outboundSchema: z.ZodType<
  BrokerCapacityOpen,
  z.ZodTypeDef,
  BrokerCapacityOpen
> = z.union([
  z.nativeEnum(BrokerCapacity),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BrokerCapacity$ {
  /** @deprecated use `BrokerCapacity$inboundSchema` instead. */
  export const inboundSchema = BrokerCapacity$inboundSchema;
  /** @deprecated use `BrokerCapacity$outboundSchema` instead. */
  export const outboundSchema = BrokerCapacity$outboundSchema;
}

/** @internal */
export const IdentifierType$inboundSchema: z.ZodType<
  IdentifierTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(IdentifierType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const IdentifierType$outboundSchema: z.ZodType<
  IdentifierTypeOpen,
  z.ZodTypeDef,
  IdentifierTypeOpen
> = z.union([
  z.nativeEnum(IdentifierType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IdentifierType$ {
  /** @deprecated use `IdentifierType$inboundSchema` instead. */
  export const inboundSchema = IdentifierType$inboundSchema;
  /** @deprecated use `IdentifierType$outboundSchema` instead. */
  export const outboundSchema = IdentifierType$outboundSchema;
}

/** @internal */
export const OrderType$inboundSchema: z.ZodType<
  OrderTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OrderType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OrderType$outboundSchema: z.ZodType<
  OrderTypeOpen,
  z.ZodTypeDef,
  OrderTypeOpen
> = z.union([
  z.nativeEnum(OrderType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OrderType$ {
  /** @deprecated use `OrderType$inboundSchema` instead. */
  export const inboundSchema = OrderType$inboundSchema;
  /** @deprecated use `OrderType$outboundSchema` instead. */
  export const outboundSchema = OrderType$outboundSchema;
}

/** @internal */
export const Side$inboundSchema: z.ZodType<SideOpen, z.ZodTypeDef, unknown> = z
  .union([
    z.nativeEnum(Side),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const Side$outboundSchema: z.ZodType<SideOpen, z.ZodTypeDef, SideOpen> =
  z.union([
    z.nativeEnum(Side),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Side$ {
  /** @deprecated use `Side$inboundSchema` instead. */
  export const inboundSchema = Side$inboundSchema;
  /** @deprecated use `Side$outboundSchema` instead. */
  export const outboundSchema = Side$outboundSchema;
}

/** @internal */
export const SpecialReportingInstructions$inboundSchema: z.ZodType<
  SpecialReportingInstructionsOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(SpecialReportingInstructions),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const SpecialReportingInstructions$outboundSchema: z.ZodType<
  SpecialReportingInstructionsOpen,
  z.ZodTypeDef,
  SpecialReportingInstructionsOpen
> = z.union([
  z.nativeEnum(SpecialReportingInstructions),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SpecialReportingInstructions$ {
  /** @deprecated use `SpecialReportingInstructions$inboundSchema` instead. */
  export const inboundSchema = SpecialReportingInstructions$inboundSchema;
  /** @deprecated use `SpecialReportingInstructions$outboundSchema` instead. */
  export const outboundSchema = SpecialReportingInstructions$outboundSchema;
}

/** @internal */
export const TimeInForce$inboundSchema: z.ZodType<
  TimeInForceOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(TimeInForce),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const TimeInForce$outboundSchema: z.ZodType<
  TimeInForceOpen,
  z.ZodTypeDef,
  TimeInForceOpen
> = z.union([
  z.nativeEnum(TimeInForce),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TimeInForce$ {
  /** @deprecated use `TimeInForce$inboundSchema` instead. */
  export const inboundSchema = TimeInForce$inboundSchema;
  /** @deprecated use `TimeInForce$outboundSchema` instead. */
  export const outboundSchema = TimeInForce$outboundSchema;
}

/** @internal */
export const OrderCreate$inboundSchema: z.ZodType<
  OrderCreate,
  z.ZodTypeDef,
  unknown
> = z.object({
  asset_type: AssetType$inboundSchema,
  broker_capacity: BrokerCapacity$inboundSchema.optional(),
  client_order_id: z.string(),
  client_received_time: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ).optional(),
  commission: CommissionCreate$inboundSchema.optional(),
  currency_code: z.string().optional(),
  fees: z.array(FeeCreate$inboundSchema).optional(),
  identifier: z.string(),
  identifier_issuing_region_code: z.string().optional(),
  identifier_type: IdentifierType$inboundSchema,
  letter_of_intent: LetterOfIntentCreate$inboundSchema.optional(),
  limit_price: LimitPriceCreate$inboundSchema.optional(),
  max_sell_quantity: DecimalCreate$inboundSchema.optional(),
  notional_value: DecimalCreate$inboundSchema.optional(),
  order_date: DateCreate$inboundSchema,
  order_type: OrderType$inboundSchema,
  quantity: DecimalCreate$inboundSchema.optional(),
  rights_of_accumulation: RightsOfAccumulationCreate$inboundSchema.optional(),
  side: Side$inboundSchema,
  special_reporting_instructions: z.array(
    SpecialReportingInstructions$inboundSchema,
  ).optional(),
  stop_price: StopPriceCreate$inboundSchema.optional(),
  time_in_force: TimeInForce$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "asset_type": "assetType",
    "broker_capacity": "brokerCapacity",
    "client_order_id": "clientOrderId",
    "client_received_time": "clientReceivedTime",
    "currency_code": "currencyCode",
    "identifier_issuing_region_code": "identifierIssuingRegionCode",
    "identifier_type": "identifierType",
    "letter_of_intent": "letterOfIntent",
    "limit_price": "limitPrice",
    "max_sell_quantity": "maxSellQuantity",
    "notional_value": "notionalValue",
    "order_date": "orderDate",
    "order_type": "orderType",
    "rights_of_accumulation": "rightsOfAccumulation",
    "special_reporting_instructions": "specialReportingInstructions",
    "stop_price": "stopPrice",
    "time_in_force": "timeInForce",
  });
});

/** @internal */
export type OrderCreate$Outbound = {
  asset_type: string;
  broker_capacity?: string | undefined;
  client_order_id: string;
  client_received_time?: string | null | undefined;
  commission?: CommissionCreate$Outbound | undefined;
  currency_code?: string | undefined;
  fees?: Array<FeeCreate$Outbound> | undefined;
  identifier: string;
  identifier_issuing_region_code?: string | undefined;
  identifier_type: string;
  letter_of_intent?: LetterOfIntentCreate$Outbound | undefined;
  limit_price?: LimitPriceCreate$Outbound | undefined;
  max_sell_quantity?: DecimalCreate$Outbound | undefined;
  notional_value?: DecimalCreate$Outbound | undefined;
  order_date: DateCreate$Outbound;
  order_type: string;
  quantity?: DecimalCreate$Outbound | undefined;
  rights_of_accumulation?: RightsOfAccumulationCreate$Outbound | undefined;
  side: string;
  special_reporting_instructions?: Array<string> | undefined;
  stop_price?: StopPriceCreate$Outbound | undefined;
  time_in_force: string;
};

/** @internal */
export const OrderCreate$outboundSchema: z.ZodType<
  OrderCreate$Outbound,
  z.ZodTypeDef,
  OrderCreate
> = z.object({
  assetType: AssetType$outboundSchema,
  brokerCapacity: BrokerCapacity$outboundSchema.optional(),
  clientOrderId: z.string(),
  clientReceivedTime: z.nullable(z.date().transform(v => v.toISOString()))
    .optional(),
  commission: CommissionCreate$outboundSchema.optional(),
  currencyCode: z.string().optional(),
  fees: z.array(FeeCreate$outboundSchema).optional(),
  identifier: z.string(),
  identifierIssuingRegionCode: z.string().optional(),
  identifierType: IdentifierType$outboundSchema,
  letterOfIntent: LetterOfIntentCreate$outboundSchema.optional(),
  limitPrice: LimitPriceCreate$outboundSchema.optional(),
  maxSellQuantity: DecimalCreate$outboundSchema.optional(),
  notionalValue: DecimalCreate$outboundSchema.optional(),
  orderDate: DateCreate$outboundSchema,
  orderType: OrderType$outboundSchema,
  quantity: DecimalCreate$outboundSchema.optional(),
  rightsOfAccumulation: RightsOfAccumulationCreate$outboundSchema.optional(),
  side: Side$outboundSchema,
  specialReportingInstructions: z.array(
    SpecialReportingInstructions$outboundSchema,
  ).optional(),
  stopPrice: StopPriceCreate$outboundSchema.optional(),
  timeInForce: TimeInForce$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    assetType: "asset_type",
    brokerCapacity: "broker_capacity",
    clientOrderId: "client_order_id",
    clientReceivedTime: "client_received_time",
    currencyCode: "currency_code",
    identifierIssuingRegionCode: "identifier_issuing_region_code",
    identifierType: "identifier_type",
    letterOfIntent: "letter_of_intent",
    limitPrice: "limit_price",
    maxSellQuantity: "max_sell_quantity",
    notionalValue: "notional_value",
    orderDate: "order_date",
    orderType: "order_type",
    rightsOfAccumulation: "rights_of_accumulation",
    specialReportingInstructions: "special_reporting_instructions",
    stopPrice: "stop_price",
    timeInForce: "time_in_force",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OrderCreate$ {
  /** @deprecated use `OrderCreate$inboundSchema` instead. */
  export const inboundSchema = OrderCreate$inboundSchema;
  /** @deprecated use `OrderCreate$outboundSchema` instead. */
  export const outboundSchema = OrderCreate$outboundSchema;
  /** @deprecated use `OrderCreate$Outbound` instead. */
  export type Outbound = OrderCreate$Outbound;
}
