/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import {
  catchUnrecognizedEnum,
  OpenEnum,
  Unrecognized,
} from "../../types/enums.js";
import {
  OptionDeliverable,
  OptionDeliverable$inboundSchema,
  OptionDeliverable$Outbound,
  OptionDeliverable$outboundSchema,
} from "./optiondeliverable.js";

/**
 * Indicates the type of currency
 */
export enum CurrencyType {
  CurrencyTypeUnspecified = "CURRENCY_TYPE_UNSPECIFIED",
  Currency = "CURRENCY",
  CurrencyEquivalent = "CURRENCY_EQUIVALENT",
}
/**
 * Indicates the type of currency
 */
export type CurrencyTypeOpen = OpenEnum<typeof CurrencyType>;

/**
 * Currency specific asset details
 */
export type Currency = {
  /**
   * Indicates the type of currency
   */
  currencyType?: CurrencyTypeOpen | undefined;
  /**
   * Indicates the name of asset for the underlying payment_currency when the `currency_type` is `CURRENCY_EQUIVALENT`
   */
  paymentCurrency?: string | undefined;
};

/**
 * the code indicating the type of associated security.
 */
export enum AssetEquityType {
  EquityTypeUnspecified = "EQUITY_TYPE_UNSPECIFIED",
  CommonStock = "COMMON_STOCK",
  PreferredStock = "PREFERRED_STOCK",
  PreferredAdr = "PREFERRED_ADR",
  SpecialStock = "SPECIAL_STOCK",
  Index = "INDEX",
  Warrant = "WARRANT",
  Adr = "ADR",
  Rights = "RIGHTS",
  SharesOfBeneficialInterest = "SHARES_OF_BENEFICIAL_INTEREST",
  Certificates = "CERTIFICATES",
  Units = "UNITS",
  DebtIssue = "DEBT_ISSUE",
  EquityTypeOption = "EQUITY_TYPE_OPTION",
  Etf = "ETF",
}
/**
 * the code indicating the type of associated security.
 */
export type AssetEquityTypeOpen = OpenEnum<typeof AssetEquityType>;

/**
 * Equity specific asset details
 */
export type Equity = {
  /**
   * Indicates whether the symbol is eligible for fractional or notional execution for orders at Apex
   */
  fractionable?: boolean | undefined;
  /**
   * Indicates whether the symbol is designated as “Liquidate Only,” and, if so, the system rejects purchases
   */
  liquidate?: boolean | undefined;
  /**
   * the code indicating the type of associated security.
   */
  type?: AssetEquityTypeOpen | undefined;
};

/**
 * The type of call
 */
export enum CallType {
  CallTypeUnspecified = "CALL_TYPE_UNSPECIFIED",
  Ordinary = "ORDINARY",
  Special = "SPECIAL",
  MakeWhole = "MAKE_WHOLE",
  Regulatory = "REGULATORY",
}
/**
 * The type of call
 */
export type CallTypeOpen = OpenEnum<typeof CallType>;

/**
 * Frequency of payments
 */
export enum CouponFrequency {
  CouponFrequencyUnspecified = "COUPON_FREQUENCY_UNSPECIFIED",
  SemiAnnual = "SEMI_ANNUAL",
  Monthly = "MONTHLY",
  AtMaturity = "AT_MATURITY",
  Zero = "ZERO",
  Quarterly = "QUARTERLY",
  Annual = "ANNUAL",
}
/**
 * Frequency of payments
 */
export type CouponFrequencyOpen = OpenEnum<typeof CouponFrequency>;

/**
 * A measure of income an investor can expect to receive expressed as a percent
 */
export type CouponRate = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Type of coupon rate
 */
export enum CouponType {
  CouponTypeUnspecified = "COUPON_TYPE_UNSPECIFIED",
  CouponTypeFixed = "COUPON_TYPE_FIXED",
  CouponTypeZero = "COUPON_TYPE_ZERO",
}
/**
 * Type of coupon rate
 */
export type CouponTypeOpen = OpenEnum<typeof CouponType>;

/**
 * Weighted average time until a bond’s cash flows are received in years
 */
export type Duration = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * date of first coupon
 */
export type FirstCouponDate = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * The status of the fixed income
 */
export enum FixedIncomeStatus {
  FixedIncomeStatusUnspecified = "FIXED_INCOME_STATUS_UNSPECIFIED",
  Outstanding = "OUTSTANDING",
  Matured = "MATURED",
  Called = "CALLED",
  Unknown = "UNKNOWN",
  Defaulted = "DEFAULTED",
  Converted = "CONVERTED",
  Tendered = "TENDERED",
  PreIssuance = "PRE_ISSUANCE",
  Liquidated = "LIQUIDATED",
  Repurchased = "REPURCHASED",
  Repaid = "REPAID",
  Restructured = "RESTRUCTURED",
  Put = "PUT",
  Funged = "FUNGED",
}
/**
 * The status of the fixed income
 */
export type FixedIncomeStatusOpen = OpenEnum<typeof FixedIncomeStatus>;

/**
 * The type of treasury
 */
export enum FixedIncomeSubtype {
  FixedIncomeSubtypeUnspecified = "FIXED_INCOME_SUBTYPE_UNSPECIFIED",
  Bond = "BOND",
  Strips = "STRIPS",
  Bill = "BILL",
  Note = "NOTE",
  Tips = "TIPS",
}
/**
 * The type of treasury
 */
export type FixedIncomeSubtypeOpen = OpenEnum<typeof FixedIncomeSubtype>;

/**
 * Type of fixed income security
 */
export enum FixedIncomeType {
  FixedIncomeTypeUnspecified = "FIXED_INCOME_TYPE_UNSPECIFIED",
  Municipal = "MUNICIPAL",
  Corporate = "CORPORATE",
  Cd = "CD",
  Agency = "AGENCY",
  Treasury = "TREASURY",
  Government = "GOVERNMENT",
  ForeignGovernment = "FOREIGN_GOVERNMENT",
}
/**
 * Type of fixed income security
 */
export type FixedIncomeTypeOpen = OpenEnum<typeof FixedIncomeType>;

/**
 * The date of issuance
 */
export type AssetIssueDate = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * Total size of the bond issue in the issuing currency
 */
export type IssueSize = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * date of last coupon
 */
export type LastCouponDate = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * The date the fixed income security matures
 */
export type MaturityDate = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * The date of the next call
 */
export type NextCallDate = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * Date of next coupon payment
 */
export type NextCouponDate = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * The amount the issuer agrees to pay the investor upon maturity
 */
export type ParValue = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * The price at which fixed income security was issued as a percentage of par value in %
 */
export type PriceAtIssuance = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Standard & Poor's (S&P) rating of the creditworthiness of borrowers. Correspondents must be configured to view this field.
 */
export enum SpRating {
  SpRatingUnspecified = "SP_RATING_UNSPECIFIED",
  Aaa = "AAA",
  AaPlus = "AA_PLUS",
  Aa = "AA",
  AaMinus = "AA_MINUS",
  APlus = "A_PLUS",
  A = "A",
  AMinus = "A_MINUS",
  BbbPlus = "BBB_PLUS",
  Bbb = "BBB",
  BbbMinus = "BBB_MINUS",
  BbPlus = "BB_PLUS",
  Bb = "BB",
  BbMinus = "BB_MINUS",
  BPlus = "B_PLUS",
  B = "B",
  BMinus = "B_MINUS",
  CccPlus = "CCC_PLUS",
  Ccc = "CCC",
  CccMinus = "CCC_MINUS",
  Cc = "CC",
  C = "C",
  D = "D",
  Nr = "NR",
  Sp1Plus = "SP_1_PLUS",
  Sp1 = "SP_1",
  Sp1Minus = "SP_1_MINUS",
  A1Plus = "A_1_PLUS",
  A1 = "A_1",
  A1Minus = "A_1_MINUS",
}
/**
 * Standard & Poor's (S&P) rating of the creditworthiness of borrowers. Correspondents must be configured to view this field.
 */
export type SpRatingOpen = OpenEnum<typeof SpRating>;

/**
 * The date of Standard & Poor's (S&P) rating of the creditworthiness of borrowers. Correspondents must be configured to view this field.
 */
export type SpRatingDate = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * FixedIncome specific asset details
 */
export type FixedIncome = {
  /**
   * The type of call
   */
  callType?: CallTypeOpen | undefined;
  /**
   * Boolean that indicates whether an issuer may redeem the security before its maturity date
   */
  callable?: boolean | undefined;
  /**
   * Boolean that indicates whether an investor may convert to a number of shares of issuer common stock
   */
  convertible?: boolean | undefined;
  /**
   * Frequency of payments
   */
  couponFrequency?: CouponFrequencyOpen | undefined;
  /**
   * A measure of income an investor can expect to receive expressed as a percent
   */
  couponRate?: CouponRate | null | undefined;
  /**
   * Type of coupon rate
   */
  couponType?: CouponTypeOpen | undefined;
  /**
   * Weighted average time until a bond’s cash flows are received in years
   */
  duration?: Duration | null | undefined;
  /**
   * date of first coupon
   */
  firstCouponDate?: FirstCouponDate | null | undefined;
  /**
   * The status of the fixed income
   */
  fixedIncomeStatus?: FixedIncomeStatusOpen | undefined;
  /**
   * The type of treasury
   */
  fixedIncomeSubtype?: FixedIncomeSubtypeOpen | undefined;
  /**
   * Type of fixed income security
   */
  fixedIncomeType?: FixedIncomeTypeOpen | undefined;
  /**
   * Boolean that indicates whether a security is backed by an insurance policy
   */
  insured?: boolean | undefined;
  /**
   * The date of issuance
   */
  issueDate?: AssetIssueDate | null | undefined;
  /**
   * Total size of the bond issue in the issuing currency
   */
  issueSize?: IssueSize | null | undefined;
  /**
   * Name of the bond issuer
   */
  issuer?: string | undefined;
  /**
   * date of last coupon
   */
  lastCouponDate?: LastCouponDate | null | undefined;
  /**
   * The date the fixed income security matures
   */
  maturityDate?: MaturityDate | null | undefined;
  /**
   * The date of the next call
   */
  nextCallDate?: NextCallDate | null | undefined;
  /**
   * Date of next coupon payment
   */
  nextCouponDate?: NextCouponDate | null | undefined;
  /**
   * The amount the issuer agrees to pay the investor upon maturity
   */
  parValue?: ParValue | null | undefined;
  /**
   * Indicates whether the bond is perpetual
   */
  perpetual?: boolean | undefined;
  /**
   * The price at which fixed income security was issued as a percentage of par value in %
   */
  priceAtIssuance?: PriceAtIssuance | null | undefined;
  /**
   * Standard & Poor's (S&P) rating of the creditworthiness of borrowers. Correspondents must be configured to view this field.
   */
  spRating?: SpRatingOpen | undefined;
  /**
   * The date of Standard & Poor's (S&P) rating of the creditworthiness of borrowers. Correspondents must be configured to view this field.
   */
  spRatingDate?: SpRatingDate | null | undefined;
  /**
   * The symbol for the issuer’s equity
   */
  underlyingSymbol?: string | undefined;
};

/**
 * The threshold at which Apex would need to notify the fund family of an incoming large order.
 */
export type LargeOrderNotificationAmount = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Identifies type of mutual fund
 */
export enum MutualFundType {
  MutualFundTypeUnspecified = "MUTUAL_FUND_TYPE_UNSPECIFIED",
  Bond = "BOND",
  MoneyMarketFund = "MONEY_MARKET_FUND",
  Equity = "EQUITY",
}
/**
 * Identifies type of mutual fund
 */
export type MutualFundTypeOpen = OpenEnum<typeof MutualFundType>;

/**
 * MutualFund specific asset details
 */
export type MutualFund = {
  /**
   * Name of the fund company
   */
  fundFamily?: string | undefined;
  /**
   * The threshold at which Apex would need to notify the fund family of an incoming large order.
   */
  largeOrderNotificationAmount?:
    | LargeOrderNotificationAmount
    | null
    | undefined;
  /**
   * Identifies type of mutual fund
   */
  mutualFundType?: MutualFundTypeOpen | undefined;
  /**
   * Indicates the type and number of fees charged for the shares in a fund
   */
  shareClass?: string | undefined;
};

/**
 * Indicates whether the option is a Call or a Put. A Put entitles the holder to sell shares at the specified strike_price, while a Call entitles the holder to buy shares at the specified strike_price.
 */
export enum CallPut {
  CallPutUnspecified = "CALL_PUT_UNSPECIFIED",
  Call = "CALL",
  Put = "PUT",
}
/**
 * Indicates whether the option is a Call or a Put. A Put entitles the holder to sell shares at the specified strike_price, while a Call entitles the holder to buy shares at the specified strike_price.
 */
export type CallPutOpen = OpenEnum<typeof CallPut>;

/**
 * Indicates how and when an option can be exercised, either American (exercise any time before expiration) or European (exercise only at expiration).
 */
export enum ExerciseStyle {
  ExerciseStyleUnspecified = "EXERCISE_STYLE_UNSPECIFIED",
  American = "AMERICAN",
  European = "EUROPEAN",
}
/**
 * Indicates how and when an option can be exercised, either American (exercise any time before expiration) or European (exercise only at expiration).
 */
export type ExerciseStyleOpen = OpenEnum<typeof ExerciseStyle>;

/**
 * The date when the option contract expires. This will typically match the series_date but can vary when the option expiration is accelerated for a given series. This field will represent the actual expiration date.
 */
export type AssetExpirationDate = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * Classification is the category of option that the option falls into These are based on how the contract was written. Only STANDARD is supported at this time.
 */
export enum Classification {
  ClassificationUnspecified = "CLASSIFICATION_UNSPECIFIED",
  Standard = "STANDARD",
  Flex = "FLEX",
}
/**
 * Classification is the category of option that the option falls into These are based on how the contract was written. Only STANDARD is supported at this time.
 */
export type ClassificationOpen = OpenEnum<typeof Classification>;

/**
 * The penny pilot indicator of the option
 */
export enum PennyPilotIndicator {
  PennyPilotIndicatorUnspecified = "PENNY_PILOT_INDICATOR_UNSPECIFIED",
  PennyPilot = "PENNY_PILOT",
  NonPennyPilot = "NON_PENNY_PILOT",
}
/**
 * The penny pilot indicator of the option
 */
export type PennyPilotIndicatorOpen = OpenEnum<typeof PennyPilotIndicator>;

/**
 * The position Limit for a given option set at the OCC.
 */
export type PositionLimit = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Indicates whether the option is designated to settle at the market's opening price on the expiration date.
 */
export enum SettlementStyle {
  SettlementStyleUnspecified = "SETTLEMENT_STYLE_UNSPECIFIED",
  SettleOnOpen = "SETTLE_ON_OPEN",
  SettleOnClose = "SETTLE_ON_CLOSE",
}
/**
 * Indicates whether the option is designated to settle at the market's opening price on the expiration date.
 */
export type SettlementStyleOpen = OpenEnum<typeof SettlementStyle>;

/**
 * A number that identifies where the decimal for a strike price should be within the OSI.  For example, in the OSI: AAPL 210416C00120000,   a strike_multiplier of 1 indicates that the strike price is $120.000 and a strike_multiplier of .1 indicates that the strike price is $12.00.
 *
 * @remarks
 *
 *  strike_multiplier is: always 1.0 for Equity Options, usually 1.0 for Index Options, but is 0.1 for “half-point” Index Options.
 */
export type StrikeMultiplier = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * A number defined as 1 unit of strike value.  For example, if the strike price multiplier = 100, then a strike of $17 equals $1,700. This field is used for  calculating extended strike values.  The number of units represented by the Strike Price Multiplier is comprised of:
 *
 * @remarks
 *    1) Number of shares for Equity Options
 *    2) A dollar amount for Index Options
 *  The typical value of this multiplier for Equity and Index options is 100
 *  For mini options the typical value is 10
 */
export type StrikePriceMultiplier = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * A number defined as 1 unit of trade premium value.  For example, if the multiplier = 100, then a premium of $1.50 equals $150. This field is used for calculating premium money extensions.  The number of units represented by the multiplier is comprised of:
 *
 * @remarks
 *   1) Number of shares for Equity Options
 *   2) A dollar amount for Index Options
 *  The typical value of this multiplier for Equity and Index options is 100. In the majority of cases,
 *  the Trade Premium has to be extended to the same base as the Strike Price. Therefore, the
 *   Trade Value is usually the same as the Strike Value.
 *  For mini options the typical value is 10
 */
export type TradeValueMultiplier = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * The full option root information
 */
export type OptionRoot = {
  /**
   * Classification is the category of option that the option falls into These are based on how the contract was written. Only STANDARD is supported at this time.
   */
  classification?: ClassificationOpen | undefined;
  /**
   * deliverables is the deliverables of the option More than 20 deliverable assets are not supported.
   */
  deliverables?: Array<OptionDeliverable> | undefined;
  /**
   * The penny pilot indicator of the option
   */
  pennyPilotIndicator?: PennyPilotIndicatorOpen | undefined;
  /**
   * The position Limit for a given option set at the OCC.
   */
  positionLimit?: PositionLimit | null | undefined;
  /**
   * Unique identifier for the underlying asset and its associated option contracts, which reflects any changes to the underlying asset caused by corporate actions such as mergers, splits, or spin-offs by updating the root with a numerical value to reflect the adjusted terms or entity.
   */
  rootSymbol?: string | undefined;
  /**
   * Indicates whether the option is designated to settle at the market's opening price on the expiration date.
   */
  settlementStyle?: SettlementStyleOpen | undefined;
  /**
   * A number that identifies where the decimal for a strike price should be within the OSI.  For example, in the OSI: AAPL 210416C00120000,   a strike_multiplier of 1 indicates that the strike price is $120.000 and a strike_multiplier of .1 indicates that the strike price is $12.00.
   *
   * @remarks
   *
   *  strike_multiplier is: always 1.0 for Equity Options, usually 1.0 for Index Options, but is 0.1 for “half-point” Index Options.
   */
  strikeMultiplier?: StrikeMultiplier | null | undefined;
  /**
   * A number defined as 1 unit of strike value.  For example, if the strike price multiplier = 100, then a strike of $17 equals $1,700. This field is used for  calculating extended strike values.  The number of units represented by the Strike Price Multiplier is comprised of:
   *
   * @remarks
   *    1) Number of shares for Equity Options
   *    2) A dollar amount for Index Options
   *  The typical value of this multiplier for Equity and Index options is 100
   *  For mini options the typical value is 10
   */
  strikePriceMultiplier?: StrikePriceMultiplier | null | undefined;
  /**
   * A number defined as 1 unit of trade premium value.  For example, if the multiplier = 100, then a premium of $1.50 equals $150. This field is used for calculating premium money extensions.  The number of units represented by the multiplier is comprised of:
   *
   * @remarks
   *   1) Number of shares for Equity Options
   *   2) A dollar amount for Index Options
   *  The typical value of this multiplier for Equity and Index options is 100. In the majority of cases,
   *  the Trade Premium has to be extended to the same base as the Strike Price. Therefore, the
   *   Trade Value is usually the same as the Strike Value.
   *  For mini options the typical value is 10
   */
  tradeValueMultiplier?: TradeValueMultiplier | null | undefined;
};

/**
 * Type of deliverable asset the option is set to deliver upon expiry.
 */
export enum OptionType {
  OptionTypeUnspecified = "OPTION_TYPE_UNSPECIFIED",
  Equity = "EQUITY",
  Index = "INDEX",
}
/**
 * Type of deliverable asset the option is set to deliver upon expiry.
 */
export type OptionTypeOpen = OpenEnum<typeof OptionType>;

/**
 * The date of the option contract this is the value in the OSI and is typically the same as the expiration_date but can vary when the option expiration is accelerated.
 */
export type SeriesDate = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * Specifies how an option is settled at expiration, either Physical (delivery of the underlying asset) or Cash (payment of the cash difference).
 */
export enum SettlementMethod {
  SettlementMethodUnspecified = "SETTLEMENT_METHOD_UNSPECIFIED",
  Cash = "CASH",
  Physical = "PHYSICAL",
}
/**
 * Specifies how an option is settled at expiration, either Physical (delivery of the underlying asset) or Cash (payment of the cash difference).
 */
export type SettlementMethodOpen = OpenEnum<typeof SettlementMethod>;

/**
 * Indicates whether an option follows Standard settlement terms or has Non-Standard terms, often due to adjustments like corporate actions.
 */
export enum SettlementType {
  SettlementTypeUnspecified = "SETTLEMENT_TYPE_UNSPECIFIED",
  Standard = "STANDARD",
  NonStandard = "NON_STANDARD",
}
/**
 * Indicates whether an option follows Standard settlement terms or has Non-Standard terms, often due to adjustments like corporate actions.
 */
export type SettlementTypeOpen = OpenEnum<typeof SettlementType>;

/**
 * The price at which the option holder can buy or sell the deliverable asset(s)
 */
export type StrikePrice = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Option specific asset details
 */
export type Option = {
  /**
   * Indicates whether the option is a Call or a Put. A Put entitles the holder to sell shares at the specified strike_price, while a Call entitles the holder to buy shares at the specified strike_price.
   */
  callPut?: CallPutOpen | undefined;
  /**
   * Indicates how and when an option can be exercised, either American (exercise any time before expiration) or European (exercise only at expiration).
   */
  exerciseStyle?: ExerciseStyleOpen | undefined;
  /**
   * The date when the option contract expires. This will typically match the series_date but can vary when the option expiration is accelerated for a given series. This field will represent the actual expiration date.
   */
  expirationDate?: AssetExpirationDate | null | undefined;
  /**
   * The full option root information
   */
  optionRoot?: OptionRoot | null | undefined;
  /**
   * Type of deliverable asset the option is set to deliver upon expiry.
   */
  optionType?: OptionTypeOpen | undefined;
  /**
   * The leading segment of the OSI, which is typically the original deliverable symbol of the option. There are frequent exceptions to this rule, such as when there are multiple deliverables or the deliverable goes through a corporate action.
   */
  rootSymbol?: string | undefined;
  /**
   * The date of the option contract this is the value in the OSI and is typically the same as the expiration_date but can vary when the option expiration is accelerated.
   */
  seriesDate?: SeriesDate | null | undefined;
  /**
   * Specifies how an option is settled at expiration, either Physical (delivery of the underlying asset) or Cash (payment of the cash difference).
   */
  settlementMethod?: SettlementMethodOpen | undefined;
  /**
   * Indicates whether an option follows Standard settlement terms or has Non-Standard terms, often due to adjustments like corporate actions.
   */
  settlementType?: SettlementTypeOpen | undefined;
  /**
   * The price at which the option holder can buy or sell the deliverable asset(s)
   */
  strikePrice?: StrikePrice | null | undefined;
};

/**
 * The type or category of the asset
 */
export enum AssetType1 {
  TypeUnspecified = "TYPE_UNSPECIFIED",
  Equity = "EQUITY",
  Option = "OPTION",
  Currency = "CURRENCY",
  Digital = "DIGITAL",
  FdicSynthetic = "FDIC_SYNTHETIC",
  FixedIncome = "FIXED_INCOME",
  MutualFund = "MUTUAL_FUND",
}
/**
 * The type or category of the asset
 */
export type AssetType1Open = OpenEnum<typeof AssetType1>;

/**
 * Asset is the Apex representation of a security
 */
export type Asset = {
  /**
   * Apex internal identifier assigned upon entry to every security.
   */
  assetId?: string | undefined;
  /**
   * Currency specific asset details
   */
  currency?: Currency | null | undefined;
  /**
   * Identifier assigned to a security by the CUSIP Service Bureau of Standard & Poor’s Corporation
   */
  cusip?: string | undefined;
  /**
   * Name of the issuer of a security and additional descriptive information about the particular issue
   */
  description?: string | undefined;
  /**
   * Equity specific asset details
   */
  equity?: Equity | null | undefined;
  /**
   * FixedIncome specific asset details
   */
  fixedIncome?: FixedIncome | null | undefined;
  /**
   * isin is the International Securities Identification Number
   */
  isin?: string | undefined;
  /**
   * A string attribute denoting the country of issuance or where the asset is trading.
   */
  issuingRegionCode?: string | undefined;
  /**
   * MutualFund specific asset details
   */
  mutualFund?: MutualFund | null | undefined;
  /**
   * assets/{asset_id}
   */
  name?: string | undefined;
  /**
   * Option specific asset details
   */
  option?: Option | null | undefined;
  /**
   * ISO code identifying the region in which the entity was incorporated
   */
  originatingRegionCode?: string | undefined;
  /**
   * An arrangement of characters—usually letters and or numbers — usually representing securities on an exchange
   */
  symbol?: string | undefined;
  /**
   * The type or category of the asset
   */
  type?: AssetType1Open | undefined;
  /**
   * A usable asset is active in its respective market and can be traded and/or transferred
   */
  usable?: boolean | undefined;
};

/** @internal */
export const CurrencyType$inboundSchema: z.ZodType<
  CurrencyTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(CurrencyType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const CurrencyType$outboundSchema: z.ZodType<
  CurrencyTypeOpen,
  z.ZodTypeDef,
  CurrencyTypeOpen
> = z.union([
  z.nativeEnum(CurrencyType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CurrencyType$ {
  /** @deprecated use `CurrencyType$inboundSchema` instead. */
  export const inboundSchema = CurrencyType$inboundSchema;
  /** @deprecated use `CurrencyType$outboundSchema` instead. */
  export const outboundSchema = CurrencyType$outboundSchema;
}

/** @internal */
export const Currency$inboundSchema: z.ZodType<
  Currency,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency_type: CurrencyType$inboundSchema.optional(),
  payment_currency: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "currency_type": "currencyType",
    "payment_currency": "paymentCurrency",
  });
});

/** @internal */
export type Currency$Outbound = {
  currency_type?: string | undefined;
  payment_currency?: string | undefined;
};

/** @internal */
export const Currency$outboundSchema: z.ZodType<
  Currency$Outbound,
  z.ZodTypeDef,
  Currency
> = z.object({
  currencyType: CurrencyType$outboundSchema.optional(),
  paymentCurrency: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    currencyType: "currency_type",
    paymentCurrency: "payment_currency",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Currency$ {
  /** @deprecated use `Currency$inboundSchema` instead. */
  export const inboundSchema = Currency$inboundSchema;
  /** @deprecated use `Currency$outboundSchema` instead. */
  export const outboundSchema = Currency$outboundSchema;
  /** @deprecated use `Currency$Outbound` instead. */
  export type Outbound = Currency$Outbound;
}

/** @internal */
export const AssetEquityType$inboundSchema: z.ZodType<
  AssetEquityTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(AssetEquityType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const AssetEquityType$outboundSchema: z.ZodType<
  AssetEquityTypeOpen,
  z.ZodTypeDef,
  AssetEquityTypeOpen
> = z.union([
  z.nativeEnum(AssetEquityType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AssetEquityType$ {
  /** @deprecated use `AssetEquityType$inboundSchema` instead. */
  export const inboundSchema = AssetEquityType$inboundSchema;
  /** @deprecated use `AssetEquityType$outboundSchema` instead. */
  export const outboundSchema = AssetEquityType$outboundSchema;
}

/** @internal */
export const Equity$inboundSchema: z.ZodType<Equity, z.ZodTypeDef, unknown> = z
  .object({
    fractionable: z.boolean().optional(),
    liquidate: z.boolean().optional(),
    type: AssetEquityType$inboundSchema.optional(),
  });

/** @internal */
export type Equity$Outbound = {
  fractionable?: boolean | undefined;
  liquidate?: boolean | undefined;
  type?: string | undefined;
};

/** @internal */
export const Equity$outboundSchema: z.ZodType<
  Equity$Outbound,
  z.ZodTypeDef,
  Equity
> = z.object({
  fractionable: z.boolean().optional(),
  liquidate: z.boolean().optional(),
  type: AssetEquityType$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Equity$ {
  /** @deprecated use `Equity$inboundSchema` instead. */
  export const inboundSchema = Equity$inboundSchema;
  /** @deprecated use `Equity$outboundSchema` instead. */
  export const outboundSchema = Equity$outboundSchema;
  /** @deprecated use `Equity$Outbound` instead. */
  export type Outbound = Equity$Outbound;
}

/** @internal */
export const CallType$inboundSchema: z.ZodType<
  CallTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(CallType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const CallType$outboundSchema: z.ZodType<
  CallTypeOpen,
  z.ZodTypeDef,
  CallTypeOpen
> = z.union([
  z.nativeEnum(CallType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CallType$ {
  /** @deprecated use `CallType$inboundSchema` instead. */
  export const inboundSchema = CallType$inboundSchema;
  /** @deprecated use `CallType$outboundSchema` instead. */
  export const outboundSchema = CallType$outboundSchema;
}

/** @internal */
export const CouponFrequency$inboundSchema: z.ZodType<
  CouponFrequencyOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(CouponFrequency),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const CouponFrequency$outboundSchema: z.ZodType<
  CouponFrequencyOpen,
  z.ZodTypeDef,
  CouponFrequencyOpen
> = z.union([
  z.nativeEnum(CouponFrequency),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CouponFrequency$ {
  /** @deprecated use `CouponFrequency$inboundSchema` instead. */
  export const inboundSchema = CouponFrequency$inboundSchema;
  /** @deprecated use `CouponFrequency$outboundSchema` instead. */
  export const outboundSchema = CouponFrequency$outboundSchema;
}

/** @internal */
export const CouponRate$inboundSchema: z.ZodType<
  CouponRate,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type CouponRate$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const CouponRate$outboundSchema: z.ZodType<
  CouponRate$Outbound,
  z.ZodTypeDef,
  CouponRate
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CouponRate$ {
  /** @deprecated use `CouponRate$inboundSchema` instead. */
  export const inboundSchema = CouponRate$inboundSchema;
  /** @deprecated use `CouponRate$outboundSchema` instead. */
  export const outboundSchema = CouponRate$outboundSchema;
  /** @deprecated use `CouponRate$Outbound` instead. */
  export type Outbound = CouponRate$Outbound;
}

/** @internal */
export const CouponType$inboundSchema: z.ZodType<
  CouponTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(CouponType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const CouponType$outboundSchema: z.ZodType<
  CouponTypeOpen,
  z.ZodTypeDef,
  CouponTypeOpen
> = z.union([
  z.nativeEnum(CouponType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CouponType$ {
  /** @deprecated use `CouponType$inboundSchema` instead. */
  export const inboundSchema = CouponType$inboundSchema;
  /** @deprecated use `CouponType$outboundSchema` instead. */
  export const outboundSchema = CouponType$outboundSchema;
}

/** @internal */
export const Duration$inboundSchema: z.ZodType<
  Duration,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type Duration$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const Duration$outboundSchema: z.ZodType<
  Duration$Outbound,
  z.ZodTypeDef,
  Duration
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Duration$ {
  /** @deprecated use `Duration$inboundSchema` instead. */
  export const inboundSchema = Duration$inboundSchema;
  /** @deprecated use `Duration$outboundSchema` instead. */
  export const outboundSchema = Duration$outboundSchema;
  /** @deprecated use `Duration$Outbound` instead. */
  export type Outbound = Duration$Outbound;
}

/** @internal */
export const FirstCouponDate$inboundSchema: z.ZodType<
  FirstCouponDate,
  z.ZodTypeDef,
  unknown
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/** @internal */
export type FirstCouponDate$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const FirstCouponDate$outboundSchema: z.ZodType<
  FirstCouponDate$Outbound,
  z.ZodTypeDef,
  FirstCouponDate
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FirstCouponDate$ {
  /** @deprecated use `FirstCouponDate$inboundSchema` instead. */
  export const inboundSchema = FirstCouponDate$inboundSchema;
  /** @deprecated use `FirstCouponDate$outboundSchema` instead. */
  export const outboundSchema = FirstCouponDate$outboundSchema;
  /** @deprecated use `FirstCouponDate$Outbound` instead. */
  export type Outbound = FirstCouponDate$Outbound;
}

/** @internal */
export const FixedIncomeStatus$inboundSchema: z.ZodType<
  FixedIncomeStatusOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(FixedIncomeStatus),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const FixedIncomeStatus$outboundSchema: z.ZodType<
  FixedIncomeStatusOpen,
  z.ZodTypeDef,
  FixedIncomeStatusOpen
> = z.union([
  z.nativeEnum(FixedIncomeStatus),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FixedIncomeStatus$ {
  /** @deprecated use `FixedIncomeStatus$inboundSchema` instead. */
  export const inboundSchema = FixedIncomeStatus$inboundSchema;
  /** @deprecated use `FixedIncomeStatus$outboundSchema` instead. */
  export const outboundSchema = FixedIncomeStatus$outboundSchema;
}

/** @internal */
export const FixedIncomeSubtype$inboundSchema: z.ZodType<
  FixedIncomeSubtypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(FixedIncomeSubtype),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const FixedIncomeSubtype$outboundSchema: z.ZodType<
  FixedIncomeSubtypeOpen,
  z.ZodTypeDef,
  FixedIncomeSubtypeOpen
> = z.union([
  z.nativeEnum(FixedIncomeSubtype),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FixedIncomeSubtype$ {
  /** @deprecated use `FixedIncomeSubtype$inboundSchema` instead. */
  export const inboundSchema = FixedIncomeSubtype$inboundSchema;
  /** @deprecated use `FixedIncomeSubtype$outboundSchema` instead. */
  export const outboundSchema = FixedIncomeSubtype$outboundSchema;
}

/** @internal */
export const FixedIncomeType$inboundSchema: z.ZodType<
  FixedIncomeTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(FixedIncomeType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const FixedIncomeType$outboundSchema: z.ZodType<
  FixedIncomeTypeOpen,
  z.ZodTypeDef,
  FixedIncomeTypeOpen
> = z.union([
  z.nativeEnum(FixedIncomeType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FixedIncomeType$ {
  /** @deprecated use `FixedIncomeType$inboundSchema` instead. */
  export const inboundSchema = FixedIncomeType$inboundSchema;
  /** @deprecated use `FixedIncomeType$outboundSchema` instead. */
  export const outboundSchema = FixedIncomeType$outboundSchema;
}

/** @internal */
export const AssetIssueDate$inboundSchema: z.ZodType<
  AssetIssueDate,
  z.ZodTypeDef,
  unknown
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/** @internal */
export type AssetIssueDate$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const AssetIssueDate$outboundSchema: z.ZodType<
  AssetIssueDate$Outbound,
  z.ZodTypeDef,
  AssetIssueDate
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AssetIssueDate$ {
  /** @deprecated use `AssetIssueDate$inboundSchema` instead. */
  export const inboundSchema = AssetIssueDate$inboundSchema;
  /** @deprecated use `AssetIssueDate$outboundSchema` instead. */
  export const outboundSchema = AssetIssueDate$outboundSchema;
  /** @deprecated use `AssetIssueDate$Outbound` instead. */
  export type Outbound = AssetIssueDate$Outbound;
}

/** @internal */
export const IssueSize$inboundSchema: z.ZodType<
  IssueSize,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type IssueSize$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const IssueSize$outboundSchema: z.ZodType<
  IssueSize$Outbound,
  z.ZodTypeDef,
  IssueSize
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IssueSize$ {
  /** @deprecated use `IssueSize$inboundSchema` instead. */
  export const inboundSchema = IssueSize$inboundSchema;
  /** @deprecated use `IssueSize$outboundSchema` instead. */
  export const outboundSchema = IssueSize$outboundSchema;
  /** @deprecated use `IssueSize$Outbound` instead. */
  export type Outbound = IssueSize$Outbound;
}

/** @internal */
export const LastCouponDate$inboundSchema: z.ZodType<
  LastCouponDate,
  z.ZodTypeDef,
  unknown
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/** @internal */
export type LastCouponDate$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const LastCouponDate$outboundSchema: z.ZodType<
  LastCouponDate$Outbound,
  z.ZodTypeDef,
  LastCouponDate
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LastCouponDate$ {
  /** @deprecated use `LastCouponDate$inboundSchema` instead. */
  export const inboundSchema = LastCouponDate$inboundSchema;
  /** @deprecated use `LastCouponDate$outboundSchema` instead. */
  export const outboundSchema = LastCouponDate$outboundSchema;
  /** @deprecated use `LastCouponDate$Outbound` instead. */
  export type Outbound = LastCouponDate$Outbound;
}

/** @internal */
export const MaturityDate$inboundSchema: z.ZodType<
  MaturityDate,
  z.ZodTypeDef,
  unknown
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/** @internal */
export type MaturityDate$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const MaturityDate$outboundSchema: z.ZodType<
  MaturityDate$Outbound,
  z.ZodTypeDef,
  MaturityDate
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MaturityDate$ {
  /** @deprecated use `MaturityDate$inboundSchema` instead. */
  export const inboundSchema = MaturityDate$inboundSchema;
  /** @deprecated use `MaturityDate$outboundSchema` instead. */
  export const outboundSchema = MaturityDate$outboundSchema;
  /** @deprecated use `MaturityDate$Outbound` instead. */
  export type Outbound = MaturityDate$Outbound;
}

/** @internal */
export const NextCallDate$inboundSchema: z.ZodType<
  NextCallDate,
  z.ZodTypeDef,
  unknown
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/** @internal */
export type NextCallDate$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const NextCallDate$outboundSchema: z.ZodType<
  NextCallDate$Outbound,
  z.ZodTypeDef,
  NextCallDate
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NextCallDate$ {
  /** @deprecated use `NextCallDate$inboundSchema` instead. */
  export const inboundSchema = NextCallDate$inboundSchema;
  /** @deprecated use `NextCallDate$outboundSchema` instead. */
  export const outboundSchema = NextCallDate$outboundSchema;
  /** @deprecated use `NextCallDate$Outbound` instead. */
  export type Outbound = NextCallDate$Outbound;
}

/** @internal */
export const NextCouponDate$inboundSchema: z.ZodType<
  NextCouponDate,
  z.ZodTypeDef,
  unknown
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/** @internal */
export type NextCouponDate$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const NextCouponDate$outboundSchema: z.ZodType<
  NextCouponDate$Outbound,
  z.ZodTypeDef,
  NextCouponDate
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NextCouponDate$ {
  /** @deprecated use `NextCouponDate$inboundSchema` instead. */
  export const inboundSchema = NextCouponDate$inboundSchema;
  /** @deprecated use `NextCouponDate$outboundSchema` instead. */
  export const outboundSchema = NextCouponDate$outboundSchema;
  /** @deprecated use `NextCouponDate$Outbound` instead. */
  export type Outbound = NextCouponDate$Outbound;
}

/** @internal */
export const ParValue$inboundSchema: z.ZodType<
  ParValue,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type ParValue$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const ParValue$outboundSchema: z.ZodType<
  ParValue$Outbound,
  z.ZodTypeDef,
  ParValue
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ParValue$ {
  /** @deprecated use `ParValue$inboundSchema` instead. */
  export const inboundSchema = ParValue$inboundSchema;
  /** @deprecated use `ParValue$outboundSchema` instead. */
  export const outboundSchema = ParValue$outboundSchema;
  /** @deprecated use `ParValue$Outbound` instead. */
  export type Outbound = ParValue$Outbound;
}

/** @internal */
export const PriceAtIssuance$inboundSchema: z.ZodType<
  PriceAtIssuance,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type PriceAtIssuance$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const PriceAtIssuance$outboundSchema: z.ZodType<
  PriceAtIssuance$Outbound,
  z.ZodTypeDef,
  PriceAtIssuance
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PriceAtIssuance$ {
  /** @deprecated use `PriceAtIssuance$inboundSchema` instead. */
  export const inboundSchema = PriceAtIssuance$inboundSchema;
  /** @deprecated use `PriceAtIssuance$outboundSchema` instead. */
  export const outboundSchema = PriceAtIssuance$outboundSchema;
  /** @deprecated use `PriceAtIssuance$Outbound` instead. */
  export type Outbound = PriceAtIssuance$Outbound;
}

/** @internal */
export const SpRating$inboundSchema: z.ZodType<
  SpRatingOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(SpRating),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const SpRating$outboundSchema: z.ZodType<
  SpRatingOpen,
  z.ZodTypeDef,
  SpRatingOpen
> = z.union([
  z.nativeEnum(SpRating),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SpRating$ {
  /** @deprecated use `SpRating$inboundSchema` instead. */
  export const inboundSchema = SpRating$inboundSchema;
  /** @deprecated use `SpRating$outboundSchema` instead. */
  export const outboundSchema = SpRating$outboundSchema;
}

/** @internal */
export const SpRatingDate$inboundSchema: z.ZodType<
  SpRatingDate,
  z.ZodTypeDef,
  unknown
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/** @internal */
export type SpRatingDate$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const SpRatingDate$outboundSchema: z.ZodType<
  SpRatingDate$Outbound,
  z.ZodTypeDef,
  SpRatingDate
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SpRatingDate$ {
  /** @deprecated use `SpRatingDate$inboundSchema` instead. */
  export const inboundSchema = SpRatingDate$inboundSchema;
  /** @deprecated use `SpRatingDate$outboundSchema` instead. */
  export const outboundSchema = SpRatingDate$outboundSchema;
  /** @deprecated use `SpRatingDate$Outbound` instead. */
  export type Outbound = SpRatingDate$Outbound;
}

/** @internal */
export const FixedIncome$inboundSchema: z.ZodType<
  FixedIncome,
  z.ZodTypeDef,
  unknown
> = z.object({
  call_type: CallType$inboundSchema.optional(),
  callable: z.boolean().optional(),
  convertible: z.boolean().optional(),
  coupon_frequency: CouponFrequency$inboundSchema.optional(),
  coupon_rate: z.nullable(z.lazy(() => CouponRate$inboundSchema)).optional(),
  coupon_type: CouponType$inboundSchema.optional(),
  duration: z.nullable(z.lazy(() => Duration$inboundSchema)).optional(),
  first_coupon_date: z.nullable(z.lazy(() => FirstCouponDate$inboundSchema))
    .optional(),
  fixed_income_status: FixedIncomeStatus$inboundSchema.optional(),
  fixed_income_subtype: FixedIncomeSubtype$inboundSchema.optional(),
  fixed_income_type: FixedIncomeType$inboundSchema.optional(),
  insured: z.boolean().optional(),
  issue_date: z.nullable(z.lazy(() => AssetIssueDate$inboundSchema)).optional(),
  issue_size: z.nullable(z.lazy(() => IssueSize$inboundSchema)).optional(),
  issuer: z.string().optional(),
  last_coupon_date: z.nullable(z.lazy(() => LastCouponDate$inboundSchema))
    .optional(),
  maturity_date: z.nullable(z.lazy(() => MaturityDate$inboundSchema))
    .optional(),
  next_call_date: z.nullable(z.lazy(() => NextCallDate$inboundSchema))
    .optional(),
  next_coupon_date: z.nullable(z.lazy(() => NextCouponDate$inboundSchema))
    .optional(),
  par_value: z.nullable(z.lazy(() => ParValue$inboundSchema)).optional(),
  perpetual: z.boolean().optional(),
  price_at_issuance: z.nullable(z.lazy(() => PriceAtIssuance$inboundSchema))
    .optional(),
  sp_rating: SpRating$inboundSchema.optional(),
  sp_rating_date: z.nullable(z.lazy(() => SpRatingDate$inboundSchema))
    .optional(),
  underlying_symbol: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "call_type": "callType",
    "coupon_frequency": "couponFrequency",
    "coupon_rate": "couponRate",
    "coupon_type": "couponType",
    "first_coupon_date": "firstCouponDate",
    "fixed_income_status": "fixedIncomeStatus",
    "fixed_income_subtype": "fixedIncomeSubtype",
    "fixed_income_type": "fixedIncomeType",
    "issue_date": "issueDate",
    "issue_size": "issueSize",
    "last_coupon_date": "lastCouponDate",
    "maturity_date": "maturityDate",
    "next_call_date": "nextCallDate",
    "next_coupon_date": "nextCouponDate",
    "par_value": "parValue",
    "price_at_issuance": "priceAtIssuance",
    "sp_rating": "spRating",
    "sp_rating_date": "spRatingDate",
    "underlying_symbol": "underlyingSymbol",
  });
});

/** @internal */
export type FixedIncome$Outbound = {
  call_type?: string | undefined;
  callable?: boolean | undefined;
  convertible?: boolean | undefined;
  coupon_frequency?: string | undefined;
  coupon_rate?: CouponRate$Outbound | null | undefined;
  coupon_type?: string | undefined;
  duration?: Duration$Outbound | null | undefined;
  first_coupon_date?: FirstCouponDate$Outbound | null | undefined;
  fixed_income_status?: string | undefined;
  fixed_income_subtype?: string | undefined;
  fixed_income_type?: string | undefined;
  insured?: boolean | undefined;
  issue_date?: AssetIssueDate$Outbound | null | undefined;
  issue_size?: IssueSize$Outbound | null | undefined;
  issuer?: string | undefined;
  last_coupon_date?: LastCouponDate$Outbound | null | undefined;
  maturity_date?: MaturityDate$Outbound | null | undefined;
  next_call_date?: NextCallDate$Outbound | null | undefined;
  next_coupon_date?: NextCouponDate$Outbound | null | undefined;
  par_value?: ParValue$Outbound | null | undefined;
  perpetual?: boolean | undefined;
  price_at_issuance?: PriceAtIssuance$Outbound | null | undefined;
  sp_rating?: string | undefined;
  sp_rating_date?: SpRatingDate$Outbound | null | undefined;
  underlying_symbol?: string | undefined;
};

/** @internal */
export const FixedIncome$outboundSchema: z.ZodType<
  FixedIncome$Outbound,
  z.ZodTypeDef,
  FixedIncome
> = z.object({
  callType: CallType$outboundSchema.optional(),
  callable: z.boolean().optional(),
  convertible: z.boolean().optional(),
  couponFrequency: CouponFrequency$outboundSchema.optional(),
  couponRate: z.nullable(z.lazy(() => CouponRate$outboundSchema)).optional(),
  couponType: CouponType$outboundSchema.optional(),
  duration: z.nullable(z.lazy(() => Duration$outboundSchema)).optional(),
  firstCouponDate: z.nullable(z.lazy(() => FirstCouponDate$outboundSchema))
    .optional(),
  fixedIncomeStatus: FixedIncomeStatus$outboundSchema.optional(),
  fixedIncomeSubtype: FixedIncomeSubtype$outboundSchema.optional(),
  fixedIncomeType: FixedIncomeType$outboundSchema.optional(),
  insured: z.boolean().optional(),
  issueDate: z.nullable(z.lazy(() => AssetIssueDate$outboundSchema)).optional(),
  issueSize: z.nullable(z.lazy(() => IssueSize$outboundSchema)).optional(),
  issuer: z.string().optional(),
  lastCouponDate: z.nullable(z.lazy(() => LastCouponDate$outboundSchema))
    .optional(),
  maturityDate: z.nullable(z.lazy(() => MaturityDate$outboundSchema))
    .optional(),
  nextCallDate: z.nullable(z.lazy(() => NextCallDate$outboundSchema))
    .optional(),
  nextCouponDate: z.nullable(z.lazy(() => NextCouponDate$outboundSchema))
    .optional(),
  parValue: z.nullable(z.lazy(() => ParValue$outboundSchema)).optional(),
  perpetual: z.boolean().optional(),
  priceAtIssuance: z.nullable(z.lazy(() => PriceAtIssuance$outboundSchema))
    .optional(),
  spRating: SpRating$outboundSchema.optional(),
  spRatingDate: z.nullable(z.lazy(() => SpRatingDate$outboundSchema))
    .optional(),
  underlyingSymbol: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    callType: "call_type",
    couponFrequency: "coupon_frequency",
    couponRate: "coupon_rate",
    couponType: "coupon_type",
    firstCouponDate: "first_coupon_date",
    fixedIncomeStatus: "fixed_income_status",
    fixedIncomeSubtype: "fixed_income_subtype",
    fixedIncomeType: "fixed_income_type",
    issueDate: "issue_date",
    issueSize: "issue_size",
    lastCouponDate: "last_coupon_date",
    maturityDate: "maturity_date",
    nextCallDate: "next_call_date",
    nextCouponDate: "next_coupon_date",
    parValue: "par_value",
    priceAtIssuance: "price_at_issuance",
    spRating: "sp_rating",
    spRatingDate: "sp_rating_date",
    underlyingSymbol: "underlying_symbol",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FixedIncome$ {
  /** @deprecated use `FixedIncome$inboundSchema` instead. */
  export const inboundSchema = FixedIncome$inboundSchema;
  /** @deprecated use `FixedIncome$outboundSchema` instead. */
  export const outboundSchema = FixedIncome$outboundSchema;
  /** @deprecated use `FixedIncome$Outbound` instead. */
  export type Outbound = FixedIncome$Outbound;
}

/** @internal */
export const LargeOrderNotificationAmount$inboundSchema: z.ZodType<
  LargeOrderNotificationAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type LargeOrderNotificationAmount$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const LargeOrderNotificationAmount$outboundSchema: z.ZodType<
  LargeOrderNotificationAmount$Outbound,
  z.ZodTypeDef,
  LargeOrderNotificationAmount
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LargeOrderNotificationAmount$ {
  /** @deprecated use `LargeOrderNotificationAmount$inboundSchema` instead. */
  export const inboundSchema = LargeOrderNotificationAmount$inboundSchema;
  /** @deprecated use `LargeOrderNotificationAmount$outboundSchema` instead. */
  export const outboundSchema = LargeOrderNotificationAmount$outboundSchema;
  /** @deprecated use `LargeOrderNotificationAmount$Outbound` instead. */
  export type Outbound = LargeOrderNotificationAmount$Outbound;
}

/** @internal */
export const MutualFundType$inboundSchema: z.ZodType<
  MutualFundTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(MutualFundType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const MutualFundType$outboundSchema: z.ZodType<
  MutualFundTypeOpen,
  z.ZodTypeDef,
  MutualFundTypeOpen
> = z.union([
  z.nativeEnum(MutualFundType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MutualFundType$ {
  /** @deprecated use `MutualFundType$inboundSchema` instead. */
  export const inboundSchema = MutualFundType$inboundSchema;
  /** @deprecated use `MutualFundType$outboundSchema` instead. */
  export const outboundSchema = MutualFundType$outboundSchema;
}

/** @internal */
export const MutualFund$inboundSchema: z.ZodType<
  MutualFund,
  z.ZodTypeDef,
  unknown
> = z.object({
  fund_family: z.string().optional(),
  large_order_notification_amount: z.nullable(
    z.lazy(() => LargeOrderNotificationAmount$inboundSchema),
  ).optional(),
  mutual_fund_type: MutualFundType$inboundSchema.optional(),
  share_class: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "fund_family": "fundFamily",
    "large_order_notification_amount": "largeOrderNotificationAmount",
    "mutual_fund_type": "mutualFundType",
    "share_class": "shareClass",
  });
});

/** @internal */
export type MutualFund$Outbound = {
  fund_family?: string | undefined;
  large_order_notification_amount?:
    | LargeOrderNotificationAmount$Outbound
    | null
    | undefined;
  mutual_fund_type?: string | undefined;
  share_class?: string | undefined;
};

/** @internal */
export const MutualFund$outboundSchema: z.ZodType<
  MutualFund$Outbound,
  z.ZodTypeDef,
  MutualFund
> = z.object({
  fundFamily: z.string().optional(),
  largeOrderNotificationAmount: z.nullable(
    z.lazy(() => LargeOrderNotificationAmount$outboundSchema),
  ).optional(),
  mutualFundType: MutualFundType$outboundSchema.optional(),
  shareClass: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    fundFamily: "fund_family",
    largeOrderNotificationAmount: "large_order_notification_amount",
    mutualFundType: "mutual_fund_type",
    shareClass: "share_class",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MutualFund$ {
  /** @deprecated use `MutualFund$inboundSchema` instead. */
  export const inboundSchema = MutualFund$inboundSchema;
  /** @deprecated use `MutualFund$outboundSchema` instead. */
  export const outboundSchema = MutualFund$outboundSchema;
  /** @deprecated use `MutualFund$Outbound` instead. */
  export type Outbound = MutualFund$Outbound;
}

/** @internal */
export const CallPut$inboundSchema: z.ZodType<
  CallPutOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(CallPut),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const CallPut$outboundSchema: z.ZodType<
  CallPutOpen,
  z.ZodTypeDef,
  CallPutOpen
> = z.union([
  z.nativeEnum(CallPut),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CallPut$ {
  /** @deprecated use `CallPut$inboundSchema` instead. */
  export const inboundSchema = CallPut$inboundSchema;
  /** @deprecated use `CallPut$outboundSchema` instead. */
  export const outboundSchema = CallPut$outboundSchema;
}

/** @internal */
export const ExerciseStyle$inboundSchema: z.ZodType<
  ExerciseStyleOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(ExerciseStyle),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const ExerciseStyle$outboundSchema: z.ZodType<
  ExerciseStyleOpen,
  z.ZodTypeDef,
  ExerciseStyleOpen
> = z.union([
  z.nativeEnum(ExerciseStyle),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ExerciseStyle$ {
  /** @deprecated use `ExerciseStyle$inboundSchema` instead. */
  export const inboundSchema = ExerciseStyle$inboundSchema;
  /** @deprecated use `ExerciseStyle$outboundSchema` instead. */
  export const outboundSchema = ExerciseStyle$outboundSchema;
}

/** @internal */
export const AssetExpirationDate$inboundSchema: z.ZodType<
  AssetExpirationDate,
  z.ZodTypeDef,
  unknown
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/** @internal */
export type AssetExpirationDate$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const AssetExpirationDate$outboundSchema: z.ZodType<
  AssetExpirationDate$Outbound,
  z.ZodTypeDef,
  AssetExpirationDate
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AssetExpirationDate$ {
  /** @deprecated use `AssetExpirationDate$inboundSchema` instead. */
  export const inboundSchema = AssetExpirationDate$inboundSchema;
  /** @deprecated use `AssetExpirationDate$outboundSchema` instead. */
  export const outboundSchema = AssetExpirationDate$outboundSchema;
  /** @deprecated use `AssetExpirationDate$Outbound` instead. */
  export type Outbound = AssetExpirationDate$Outbound;
}

/** @internal */
export const Classification$inboundSchema: z.ZodType<
  ClassificationOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(Classification),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const Classification$outboundSchema: z.ZodType<
  ClassificationOpen,
  z.ZodTypeDef,
  ClassificationOpen
> = z.union([
  z.nativeEnum(Classification),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Classification$ {
  /** @deprecated use `Classification$inboundSchema` instead. */
  export const inboundSchema = Classification$inboundSchema;
  /** @deprecated use `Classification$outboundSchema` instead. */
  export const outboundSchema = Classification$outboundSchema;
}

/** @internal */
export const PennyPilotIndicator$inboundSchema: z.ZodType<
  PennyPilotIndicatorOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(PennyPilotIndicator),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const PennyPilotIndicator$outboundSchema: z.ZodType<
  PennyPilotIndicatorOpen,
  z.ZodTypeDef,
  PennyPilotIndicatorOpen
> = z.union([
  z.nativeEnum(PennyPilotIndicator),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PennyPilotIndicator$ {
  /** @deprecated use `PennyPilotIndicator$inboundSchema` instead. */
  export const inboundSchema = PennyPilotIndicator$inboundSchema;
  /** @deprecated use `PennyPilotIndicator$outboundSchema` instead. */
  export const outboundSchema = PennyPilotIndicator$outboundSchema;
}

/** @internal */
export const PositionLimit$inboundSchema: z.ZodType<
  PositionLimit,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type PositionLimit$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const PositionLimit$outboundSchema: z.ZodType<
  PositionLimit$Outbound,
  z.ZodTypeDef,
  PositionLimit
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PositionLimit$ {
  /** @deprecated use `PositionLimit$inboundSchema` instead. */
  export const inboundSchema = PositionLimit$inboundSchema;
  /** @deprecated use `PositionLimit$outboundSchema` instead. */
  export const outboundSchema = PositionLimit$outboundSchema;
  /** @deprecated use `PositionLimit$Outbound` instead. */
  export type Outbound = PositionLimit$Outbound;
}

/** @internal */
export const SettlementStyle$inboundSchema: z.ZodType<
  SettlementStyleOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(SettlementStyle),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const SettlementStyle$outboundSchema: z.ZodType<
  SettlementStyleOpen,
  z.ZodTypeDef,
  SettlementStyleOpen
> = z.union([
  z.nativeEnum(SettlementStyle),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SettlementStyle$ {
  /** @deprecated use `SettlementStyle$inboundSchema` instead. */
  export const inboundSchema = SettlementStyle$inboundSchema;
  /** @deprecated use `SettlementStyle$outboundSchema` instead. */
  export const outboundSchema = SettlementStyle$outboundSchema;
}

/** @internal */
export const StrikeMultiplier$inboundSchema: z.ZodType<
  StrikeMultiplier,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type StrikeMultiplier$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const StrikeMultiplier$outboundSchema: z.ZodType<
  StrikeMultiplier$Outbound,
  z.ZodTypeDef,
  StrikeMultiplier
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StrikeMultiplier$ {
  /** @deprecated use `StrikeMultiplier$inboundSchema` instead. */
  export const inboundSchema = StrikeMultiplier$inboundSchema;
  /** @deprecated use `StrikeMultiplier$outboundSchema` instead. */
  export const outboundSchema = StrikeMultiplier$outboundSchema;
  /** @deprecated use `StrikeMultiplier$Outbound` instead. */
  export type Outbound = StrikeMultiplier$Outbound;
}

/** @internal */
export const StrikePriceMultiplier$inboundSchema: z.ZodType<
  StrikePriceMultiplier,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type StrikePriceMultiplier$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const StrikePriceMultiplier$outboundSchema: z.ZodType<
  StrikePriceMultiplier$Outbound,
  z.ZodTypeDef,
  StrikePriceMultiplier
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StrikePriceMultiplier$ {
  /** @deprecated use `StrikePriceMultiplier$inboundSchema` instead. */
  export const inboundSchema = StrikePriceMultiplier$inboundSchema;
  /** @deprecated use `StrikePriceMultiplier$outboundSchema` instead. */
  export const outboundSchema = StrikePriceMultiplier$outboundSchema;
  /** @deprecated use `StrikePriceMultiplier$Outbound` instead. */
  export type Outbound = StrikePriceMultiplier$Outbound;
}

/** @internal */
export const TradeValueMultiplier$inboundSchema: z.ZodType<
  TradeValueMultiplier,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type TradeValueMultiplier$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const TradeValueMultiplier$outboundSchema: z.ZodType<
  TradeValueMultiplier$Outbound,
  z.ZodTypeDef,
  TradeValueMultiplier
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TradeValueMultiplier$ {
  /** @deprecated use `TradeValueMultiplier$inboundSchema` instead. */
  export const inboundSchema = TradeValueMultiplier$inboundSchema;
  /** @deprecated use `TradeValueMultiplier$outboundSchema` instead. */
  export const outboundSchema = TradeValueMultiplier$outboundSchema;
  /** @deprecated use `TradeValueMultiplier$Outbound` instead. */
  export type Outbound = TradeValueMultiplier$Outbound;
}

/** @internal */
export const OptionRoot$inboundSchema: z.ZodType<
  OptionRoot,
  z.ZodTypeDef,
  unknown
> = z.object({
  classification: Classification$inboundSchema.optional(),
  deliverables: z.array(OptionDeliverable$inboundSchema).optional(),
  penny_pilot_indicator: PennyPilotIndicator$inboundSchema.optional(),
  position_limit: z.nullable(z.lazy(() => PositionLimit$inboundSchema))
    .optional(),
  root_symbol: z.string().optional(),
  settlement_style: SettlementStyle$inboundSchema.optional(),
  strike_multiplier: z.nullable(z.lazy(() => StrikeMultiplier$inboundSchema))
    .optional(),
  strike_price_multiplier: z.nullable(
    z.lazy(() => StrikePriceMultiplier$inboundSchema),
  ).optional(),
  trade_value_multiplier: z.nullable(
    z.lazy(() => TradeValueMultiplier$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "penny_pilot_indicator": "pennyPilotIndicator",
    "position_limit": "positionLimit",
    "root_symbol": "rootSymbol",
    "settlement_style": "settlementStyle",
    "strike_multiplier": "strikeMultiplier",
    "strike_price_multiplier": "strikePriceMultiplier",
    "trade_value_multiplier": "tradeValueMultiplier",
  });
});

/** @internal */
export type OptionRoot$Outbound = {
  classification?: string | undefined;
  deliverables?: Array<OptionDeliverable$Outbound> | undefined;
  penny_pilot_indicator?: string | undefined;
  position_limit?: PositionLimit$Outbound | null | undefined;
  root_symbol?: string | undefined;
  settlement_style?: string | undefined;
  strike_multiplier?: StrikeMultiplier$Outbound | null | undefined;
  strike_price_multiplier?: StrikePriceMultiplier$Outbound | null | undefined;
  trade_value_multiplier?: TradeValueMultiplier$Outbound | null | undefined;
};

/** @internal */
export const OptionRoot$outboundSchema: z.ZodType<
  OptionRoot$Outbound,
  z.ZodTypeDef,
  OptionRoot
> = z.object({
  classification: Classification$outboundSchema.optional(),
  deliverables: z.array(OptionDeliverable$outboundSchema).optional(),
  pennyPilotIndicator: PennyPilotIndicator$outboundSchema.optional(),
  positionLimit: z.nullable(z.lazy(() => PositionLimit$outboundSchema))
    .optional(),
  rootSymbol: z.string().optional(),
  settlementStyle: SettlementStyle$outboundSchema.optional(),
  strikeMultiplier: z.nullable(z.lazy(() => StrikeMultiplier$outboundSchema))
    .optional(),
  strikePriceMultiplier: z.nullable(
    z.lazy(() => StrikePriceMultiplier$outboundSchema),
  ).optional(),
  tradeValueMultiplier: z.nullable(
    z.lazy(() => TradeValueMultiplier$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    pennyPilotIndicator: "penny_pilot_indicator",
    positionLimit: "position_limit",
    rootSymbol: "root_symbol",
    settlementStyle: "settlement_style",
    strikeMultiplier: "strike_multiplier",
    strikePriceMultiplier: "strike_price_multiplier",
    tradeValueMultiplier: "trade_value_multiplier",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OptionRoot$ {
  /** @deprecated use `OptionRoot$inboundSchema` instead. */
  export const inboundSchema = OptionRoot$inboundSchema;
  /** @deprecated use `OptionRoot$outboundSchema` instead. */
  export const outboundSchema = OptionRoot$outboundSchema;
  /** @deprecated use `OptionRoot$Outbound` instead. */
  export type Outbound = OptionRoot$Outbound;
}

/** @internal */
export const OptionType$inboundSchema: z.ZodType<
  OptionTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OptionType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OptionType$outboundSchema: z.ZodType<
  OptionTypeOpen,
  z.ZodTypeDef,
  OptionTypeOpen
> = z.union([
  z.nativeEnum(OptionType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OptionType$ {
  /** @deprecated use `OptionType$inboundSchema` instead. */
  export const inboundSchema = OptionType$inboundSchema;
  /** @deprecated use `OptionType$outboundSchema` instead. */
  export const outboundSchema = OptionType$outboundSchema;
}

/** @internal */
export const SeriesDate$inboundSchema: z.ZodType<
  SeriesDate,
  z.ZodTypeDef,
  unknown
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/** @internal */
export type SeriesDate$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const SeriesDate$outboundSchema: z.ZodType<
  SeriesDate$Outbound,
  z.ZodTypeDef,
  SeriesDate
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SeriesDate$ {
  /** @deprecated use `SeriesDate$inboundSchema` instead. */
  export const inboundSchema = SeriesDate$inboundSchema;
  /** @deprecated use `SeriesDate$outboundSchema` instead. */
  export const outboundSchema = SeriesDate$outboundSchema;
  /** @deprecated use `SeriesDate$Outbound` instead. */
  export type Outbound = SeriesDate$Outbound;
}

/** @internal */
export const SettlementMethod$inboundSchema: z.ZodType<
  SettlementMethodOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(SettlementMethod),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const SettlementMethod$outboundSchema: z.ZodType<
  SettlementMethodOpen,
  z.ZodTypeDef,
  SettlementMethodOpen
> = z.union([
  z.nativeEnum(SettlementMethod),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SettlementMethod$ {
  /** @deprecated use `SettlementMethod$inboundSchema` instead. */
  export const inboundSchema = SettlementMethod$inboundSchema;
  /** @deprecated use `SettlementMethod$outboundSchema` instead. */
  export const outboundSchema = SettlementMethod$outboundSchema;
}

/** @internal */
export const SettlementType$inboundSchema: z.ZodType<
  SettlementTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(SettlementType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const SettlementType$outboundSchema: z.ZodType<
  SettlementTypeOpen,
  z.ZodTypeDef,
  SettlementTypeOpen
> = z.union([
  z.nativeEnum(SettlementType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SettlementType$ {
  /** @deprecated use `SettlementType$inboundSchema` instead. */
  export const inboundSchema = SettlementType$inboundSchema;
  /** @deprecated use `SettlementType$outboundSchema` instead. */
  export const outboundSchema = SettlementType$outboundSchema;
}

/** @internal */
export const StrikePrice$inboundSchema: z.ZodType<
  StrikePrice,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type StrikePrice$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const StrikePrice$outboundSchema: z.ZodType<
  StrikePrice$Outbound,
  z.ZodTypeDef,
  StrikePrice
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StrikePrice$ {
  /** @deprecated use `StrikePrice$inboundSchema` instead. */
  export const inboundSchema = StrikePrice$inboundSchema;
  /** @deprecated use `StrikePrice$outboundSchema` instead. */
  export const outboundSchema = StrikePrice$outboundSchema;
  /** @deprecated use `StrikePrice$Outbound` instead. */
  export type Outbound = StrikePrice$Outbound;
}

/** @internal */
export const Option$inboundSchema: z.ZodType<Option, z.ZodTypeDef, unknown> = z
  .object({
    call_put: CallPut$inboundSchema.optional(),
    exercise_style: ExerciseStyle$inboundSchema.optional(),
    expiration_date: z.nullable(z.lazy(() => AssetExpirationDate$inboundSchema))
      .optional(),
    option_root: z.nullable(z.lazy(() => OptionRoot$inboundSchema)).optional(),
    option_type: OptionType$inboundSchema.optional(),
    root_symbol: z.string().optional(),
    series_date: z.nullable(z.lazy(() => SeriesDate$inboundSchema)).optional(),
    settlement_method: SettlementMethod$inboundSchema.optional(),
    settlement_type: SettlementType$inboundSchema.optional(),
    strike_price: z.nullable(z.lazy(() => StrikePrice$inboundSchema))
      .optional(),
  }).transform((v) => {
    return remap$(v, {
      "call_put": "callPut",
      "exercise_style": "exerciseStyle",
      "expiration_date": "expirationDate",
      "option_root": "optionRoot",
      "option_type": "optionType",
      "root_symbol": "rootSymbol",
      "series_date": "seriesDate",
      "settlement_method": "settlementMethod",
      "settlement_type": "settlementType",
      "strike_price": "strikePrice",
    });
  });

/** @internal */
export type Option$Outbound = {
  call_put?: string | undefined;
  exercise_style?: string | undefined;
  expiration_date?: AssetExpirationDate$Outbound | null | undefined;
  option_root?: OptionRoot$Outbound | null | undefined;
  option_type?: string | undefined;
  root_symbol?: string | undefined;
  series_date?: SeriesDate$Outbound | null | undefined;
  settlement_method?: string | undefined;
  settlement_type?: string | undefined;
  strike_price?: StrikePrice$Outbound | null | undefined;
};

/** @internal */
export const Option$outboundSchema: z.ZodType<
  Option$Outbound,
  z.ZodTypeDef,
  Option
> = z.object({
  callPut: CallPut$outboundSchema.optional(),
  exerciseStyle: ExerciseStyle$outboundSchema.optional(),
  expirationDate: z.nullable(z.lazy(() => AssetExpirationDate$outboundSchema))
    .optional(),
  optionRoot: z.nullable(z.lazy(() => OptionRoot$outboundSchema)).optional(),
  optionType: OptionType$outboundSchema.optional(),
  rootSymbol: z.string().optional(),
  seriesDate: z.nullable(z.lazy(() => SeriesDate$outboundSchema)).optional(),
  settlementMethod: SettlementMethod$outboundSchema.optional(),
  settlementType: SettlementType$outboundSchema.optional(),
  strikePrice: z.nullable(z.lazy(() => StrikePrice$outboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    callPut: "call_put",
    exerciseStyle: "exercise_style",
    expirationDate: "expiration_date",
    optionRoot: "option_root",
    optionType: "option_type",
    rootSymbol: "root_symbol",
    seriesDate: "series_date",
    settlementMethod: "settlement_method",
    settlementType: "settlement_type",
    strikePrice: "strike_price",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Option$ {
  /** @deprecated use `Option$inboundSchema` instead. */
  export const inboundSchema = Option$inboundSchema;
  /** @deprecated use `Option$outboundSchema` instead. */
  export const outboundSchema = Option$outboundSchema;
  /** @deprecated use `Option$Outbound` instead. */
  export type Outbound = Option$Outbound;
}

/** @internal */
export const AssetType1$inboundSchema: z.ZodType<
  AssetType1Open,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(AssetType1),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const AssetType1$outboundSchema: z.ZodType<
  AssetType1Open,
  z.ZodTypeDef,
  AssetType1Open
> = z.union([
  z.nativeEnum(AssetType1),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AssetType1$ {
  /** @deprecated use `AssetType1$inboundSchema` instead. */
  export const inboundSchema = AssetType1$inboundSchema;
  /** @deprecated use `AssetType1$outboundSchema` instead. */
  export const outboundSchema = AssetType1$outboundSchema;
}

/** @internal */
export const Asset$inboundSchema: z.ZodType<Asset, z.ZodTypeDef, unknown> = z
  .object({
    asset_id: z.string().optional(),
    currency: z.nullable(z.lazy(() => Currency$inboundSchema)).optional(),
    cusip: z.string().optional(),
    description: z.string().optional(),
    equity: z.nullable(z.lazy(() => Equity$inboundSchema)).optional(),
    fixed_income: z.nullable(z.lazy(() => FixedIncome$inboundSchema))
      .optional(),
    isin: z.string().optional(),
    issuing_region_code: z.string().optional(),
    mutual_fund: z.nullable(z.lazy(() => MutualFund$inboundSchema)).optional(),
    name: z.string().optional(),
    option: z.nullable(z.lazy(() => Option$inboundSchema)).optional(),
    originating_region_code: z.string().optional(),
    symbol: z.string().optional(),
    type: AssetType1$inboundSchema.optional(),
    usable: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      "asset_id": "assetId",
      "fixed_income": "fixedIncome",
      "issuing_region_code": "issuingRegionCode",
      "mutual_fund": "mutualFund",
      "originating_region_code": "originatingRegionCode",
    });
  });

/** @internal */
export type Asset$Outbound = {
  asset_id?: string | undefined;
  currency?: Currency$Outbound | null | undefined;
  cusip?: string | undefined;
  description?: string | undefined;
  equity?: Equity$Outbound | null | undefined;
  fixed_income?: FixedIncome$Outbound | null | undefined;
  isin?: string | undefined;
  issuing_region_code?: string | undefined;
  mutual_fund?: MutualFund$Outbound | null | undefined;
  name?: string | undefined;
  option?: Option$Outbound | null | undefined;
  originating_region_code?: string | undefined;
  symbol?: string | undefined;
  type?: string | undefined;
  usable?: boolean | undefined;
};

/** @internal */
export const Asset$outboundSchema: z.ZodType<
  Asset$Outbound,
  z.ZodTypeDef,
  Asset
> = z.object({
  assetId: z.string().optional(),
  currency: z.nullable(z.lazy(() => Currency$outboundSchema)).optional(),
  cusip: z.string().optional(),
  description: z.string().optional(),
  equity: z.nullable(z.lazy(() => Equity$outboundSchema)).optional(),
  fixedIncome: z.nullable(z.lazy(() => FixedIncome$outboundSchema)).optional(),
  isin: z.string().optional(),
  issuingRegionCode: z.string().optional(),
  mutualFund: z.nullable(z.lazy(() => MutualFund$outboundSchema)).optional(),
  name: z.string().optional(),
  option: z.nullable(z.lazy(() => Option$outboundSchema)).optional(),
  originatingRegionCode: z.string().optional(),
  symbol: z.string().optional(),
  type: AssetType1$outboundSchema.optional(),
  usable: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    assetId: "asset_id",
    fixedIncome: "fixed_income",
    issuingRegionCode: "issuing_region_code",
    mutualFund: "mutual_fund",
    originatingRegionCode: "originating_region_code",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Asset$ {
  /** @deprecated use `Asset$inboundSchema` instead. */
  export const inboundSchema = Asset$inboundSchema;
  /** @deprecated use `Asset$outboundSchema` instead. */
  export const outboundSchema = Asset$outboundSchema;
  /** @deprecated use `Asset$Outbound` instead. */
  export type Outbound = Asset$Outbound;
}
