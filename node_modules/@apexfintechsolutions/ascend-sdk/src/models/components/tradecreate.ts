/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import {
  catchUnrecognizedEnum,
  OpenEnum,
  Unrecognized,
} from "../../types/enums.js";
import {
  DateCreate,
  DateCreate$inboundSchema,
  DateCreate$Outbound,
  DateCreate$outboundSchema,
} from "./datecreate.js";
import {
  ExecutionCreate,
  ExecutionCreate$inboundSchema,
  ExecutionCreate$Outbound,
  ExecutionCreate$outboundSchema,
} from "./executioncreate.js";
import {
  FeeCreate,
  FeeCreate$inboundSchema,
  FeeCreate$Outbound,
  FeeCreate$outboundSchema,
} from "./feecreate.js";
import {
  LotCreate,
  LotCreate$inboundSchema,
  LotCreate$Outbound,
  LotCreate$outboundSchema,
} from "./lotcreate.js";

/**
 * Type of the asset being traded. Required for SYMBOL and CUSIP.
 */
export enum TradeCreateAssetType {
  AssetTypeUnspecified = "ASSET_TYPE_UNSPECIFIED",
  Equity = "EQUITY",
  FixedIncome = "FIXED_INCOME",
}
/**
 * Type of the asset being traded. Required for SYMBOL and CUSIP.
 */
export type TradeCreateAssetTypeOpen = OpenEnum<typeof TradeCreateAssetType>;

/**
 * Broker capacity for the trade.
 */
export enum TradeCreateBrokerCapacity {
  CapacityUnspecified = "CAPACITY_UNSPECIFIED",
  Agency = "AGENCY",
  Principal = "PRINCIPAL",
  Mixed = "MIXED",
}
/**
 * Broker capacity for the trade.
 */
export type TradeCreateBrokerCapacityOpen = OpenEnum<
  typeof TradeCreateBrokerCapacity
>;

/**
 * Identifier type for the asset being traded.
 */
export enum TradeCreateIdentifierType {
  IdentifierTypeUnspecified = "IDENTIFIER_TYPE_UNSPECIFIED",
  AssetId = "ASSET_ID",
  Symbol = "SYMBOL",
  Cusip = "CUSIP",
  Isin = "ISIN",
}
/**
 * Identifier type for the asset being traded.
 */
export type TradeCreateIdentifierTypeOpen = OpenEnum<
  typeof TradeCreateIdentifierType
>;

/**
 * Route type for the trade.
 */
export enum RouteType {
  RouteTypeUnspecified = "ROUTE_TYPE_UNSPECIFIED",
  Dma = "DMA",
  Mngd = "MNGD",
  Quik = "QUIK",
  Algo = "ALGO",
  Away = "AWAY",
  Corr = "CORR",
  Boats = "BOATS",
}
/**
 * Route type for the trade.
 */
export type RouteTypeOpen = OpenEnum<typeof RouteType>;

/**
 * Denotes if the trade is a SELL or a BUY.
 */
export enum TradeCreateSide {
  SideUnspecified = "SIDE_UNSPECIFIED",
  Buy = "BUY",
  Sell = "SELL",
}
/**
 * Denotes if the trade is a SELL or a BUY.
 */
export type TradeCreateSideOpen = OpenEnum<typeof TradeCreateSide>;

/**
 * Side modifier for the trade.
 */
export enum SideModifier {
  SideModifierUnspecified = "SIDE_MODIFIER_UNSPECIFIED",
  Short = "SHORT",
  ShortExempt = "SHORT_EXEMPT",
  ShortCover = "SHORT_COVER",
  Open = "OPEN",
  Close = "CLOSE",
}
/**
 * Side modifier for the trade.
 */
export type SideModifierOpen = OpenEnum<typeof SideModifier>;

export enum SpecialInstructions {
  SpecialInstructionsUnspecified = "SPECIAL_INSTRUCTIONS_UNSPECIFIED",
  Rule144 = "RULE_144",
  WithDividend = "WITH_DIVIDEND",
  WithRights = "WITH_RIGHTS",
  CloseContract = "CLOSE_CONTRACT",
  CoverShort = "COVER_SHORT",
  CrossTrade = "CROSS_TRADE",
  OpenContractCovered = "OPEN_CONTRACT_COVERED",
  DiscretionExercised = "DISCRETION_EXERCISED",
  DiscretionNotExercised = "DISCRETION_NOT_EXERCISED",
  OptionAssignment = "OPTION_ASSIGNMENT",
  EmployeeStockOption = "EMPLOYEE_STOCK_OPTION",
  InvestmentBanking = "INVESTMENT_BANKING",
  BrokerDealerOrder = "BROKER_DEALER_ORDER",
  MakeMarketInSecurity = "MAKE_MARKET_IN_SECURITY",
  MakeMarketSolicited = "MAKE_MARKET_SOLICITED",
  MakeMarketUnsolicited = "MAKE_MARKET_UNSOLICITED",
  CustomerDirected = "CUSTOMER_DIRECTED",
  FullyRegistered = "FULLY_REGISTERED",
  OpenContract = "OPEN_CONTRACT",
  OddlotDiffOnRequest = "ODDLOT_DIFF_ON_REQUEST",
  ProspectusEnclosed = "PROSPECTUS_ENCLOSED",
  ProspectusSeparateMail = "PROSPECTUS_SEPARATE_MAIL",
  Solicited = "SOLICITED",
  Unsolicited = "UNSOLICITED",
  XDividend = "X_DIVIDEND",
  ActingAsPrincipal = "ACTING_AS_PRINCIPAL",
  AveragePrice = "AVERAGE_PRICE",
  BrokerLiquidation = "BROKER_LIQUIDATION",
  CouponBooks = "COUPON_BOOKS",
  HasPostageFee = "HAS_POSTAGE_FEE",
  InternetOrder = "INTERNET_ORDER",
  MarginSellout = "MARGIN_SELLOUT",
  MarketMakersAsPrincipal = "MARKET_MAKERS_AS_PRINCIPAL",
  NegativeNetProceed = "NEGATIVE_NET_PROCEED",
  PreFigIndicator = "PRE_FIG_INDICATOR",
  RisklessPrincipalInstruction = "RISKLESS_PRINCIPAL_INSTRUCTION",
  ShortInstruction = "SHORT_INSTRUCTION",
  ThirdMarket = "THIRD_MARKET",
  SuppressMsrbTransmission = "SUPPRESS_MSRB_TRANSMISSION",
  SuppressTraceReporting = "SUPPRESS_TRACE_REPORTING",
  SuppressEmailNotification = "SUPPRESS_EMAIL_NOTIFICATION",
  StockReward = "STOCK_REWARD",
  SuppressRegFees = "SUPPRESS_REG_FEES",
  SuppressSecFee = "SUPPRESS_SEC_FEE",
  SuppressTafFee = "SUPPRESS_TAF_FEE",
  DividendReinvestment = "DIVIDEND_REINVESTMENT",
}
export type SpecialInstructionsOpen = OpenEnum<typeof SpecialInstructions>;

/**
 * Exchange venue
 */
export enum Venue {
  ExchangeVenueUnspecified = "EXCHANGE_VENUE_UNSPECIFIED",
  Amex = "AMEX",
  Arca = "ARCA",
  Bats = "BATS",
  BatsByx = "BATS_BYX",
  Boston = "BOSTON",
  Box = "BOX",
  Bzx = "BZX",
  C2 = "C2",
  Cboe = "CBOE",
  Chicago = "CHICAGO",
  Cincinnati = "CINCINNATI",
  Edga = "EDGA",
  Edgx = "EDGX",
  Exclearing = "EXCLEARING",
  Iex = "IEX",
  Ise = "ISE",
  IseGemini = "ISE_GEMINI",
  Miax = "MIAX",
  Nasdaq = "NASDAQ",
  NasdaqOmxBx = "NASDAQ_OMX_BX",
  Nyse = "NYSE",
  Phlx = "PHLX",
  Otc = "OTC",
  Qsr = "QSR",
}
/**
 * Exchange venue
 */
export type VenueOpen = OpenEnum<typeof Venue>;

/**
 * Denotes that this trade was either when_issued or when_distributed.
 */
export enum WhenIssued {
  WhenIssuedTypeUnspecified = "WHEN_ISSUED_TYPE_UNSPECIFIED",
  WhenIssued = "WHEN_ISSUED",
  WhenDistributed = "WHEN_DISTRIBUTED",
}
/**
 * Denotes that this trade was either when_issued or when_distributed.
 */
export type WhenIssuedOpen = OpenEnum<typeof WhenIssued>;

/**
 * A Trade represents an entire order made by a client. Trades can hold one or many executions representing partial fills that aggregate into a whole order.
 */
export type TradeCreate = {
  /**
   * A globally unique identifier referencing a single account.
   */
  accountId: string;
  /**
   * Free form instructions that can be used to provide additional instructions (that are not captured by existing special instructions) and will be put on the trade confirm.
   */
  additionalInstructions?: string | undefined;
  /**
   * Fractional support for market-makers' internal order ids.
   */
  alternateOrderId?: string | undefined;
  /**
   * Type of the asset being traded. Required for SYMBOL and CUSIP.
   */
  assetType?: TradeCreateAssetTypeOpen | undefined;
  /**
   * Broker capacity for the trade.
   */
  brokerCapacity: TradeCreateBrokerCapacityOpen;
  /**
   * The unique identifier that is associated with an order. Must be unique by date per trade per client.
   */
  clientOrderId: string;
  /**
   * Executing broker of the trade.
   */
  executingBroker?: string | undefined;
  /**
   * The executions (sometimes referred to as partial-fills) that comprise the trade.
   */
  executions: Array<ExecutionCreate>;
  /**
   * Any client calculated fees associated with the trade. Only allowed if trade.open = false. Regulatory fees will be calculated automatically if they are not explicitly overwritten or suppressed.
   */
  fees?: Array<FeeCreate> | undefined;
  /**
   * Identifier (of the type specified in `identifier_type`). Responses will supply the originally requested identifier.
   */
  identifier: string;
  /**
   * Identifier type for the asset being traded.
   */
  identifierType: TradeCreateIdentifierTypeOpen;
  /**
   * Unicode CLDR region code. Issuing Region Code is required for some `identifier_type`s, especially CUSIP.
   */
  issuingRegionCode?: string | undefined;
  /**
   * Represents a whole or partial calendar date, such as a birthday. The time of day and time zone are either specified elsewhere or are insignificant. The date is relative to the Gregorian Calendar. This can represent one of the following:
   *
   * @remarks
   *
   *  * A full date, with non-zero year, month, and day values * A month and day value, with a zero year, such as an anniversary * A year on its own, with zero month and day values * A year and month value, with a zero day, such as a credit card expiration date
   *
   *  Related types are [google.type.TimeOfDay][google.type.TimeOfDay] and `google.protobuf.Timestamp`.
   */
  localMarketTradeDate?: DateCreate | undefined;
  /**
   * One or many lot matching instructions for the trade.
   */
  lotMatchingInstructions?: Array<LotCreate> | undefined;
  /**
   * Market Identifier Code
   */
  micCode?: string | undefined;
  /**
   * State of this trade's completeness in filling. True: trade is not done filling and can append more executions onto the trade False: trade is done filling and cannot append more executions onto the trade By default, trades are closed when they are created. An open trade can later be closed by calling the CompleteTrade endpoint. Additional executions can be appended to an open trade by calling the CreateExecution endpoint. Trades that are left open will be automatically closed nightly before Ledger's EOD.
   */
  open?: boolean | undefined;
  /**
   * Street-level order id, unique by day per broker.
   */
  orderId?: string | undefined;
  /**
   * Route type for the trade.
   */
  routeType: RouteTypeOpen;
  /**
   * Represents a whole or partial calendar date, such as a birthday. The time of day and time zone are either specified elsewhere or are insignificant. The date is relative to the Gregorian Calendar. This can represent one of the following:
   *
   * @remarks
   *
   *  * A full date, with non-zero year, month, and day values * A month and day value, with a zero year, such as an anniversary * A year on its own, with zero month and day values * A year and month value, with a zero day, such as a credit card expiration date
   *
   *  Related types are [google.type.TimeOfDay][google.type.TimeOfDay] and `google.protobuf.Timestamp`.
   */
  settlementDate?: DateCreate | undefined;
  /**
   * Denotes if the trade is a SELL or a BUY.
   */
  side: TradeCreateSideOpen;
  /**
   * Side modifier for the trade.
   */
  sideModifier?: SideModifierOpen | undefined;
  /**
   * The source of the submission.
   */
  sourceApplication: string;
  /**
   * An enumerated list of values used to indicate certain attributes about a trade (E.g. DISCRETION_EXERCISED, BROKER_LIQUIDATION) and/or trigger downstream processing rules (e.g. SUPPRESS_TRACE_REPORTING)
   */
  specialInstructions?: Array<SpecialInstructionsOpen> | undefined;
  /**
   * Exchange venue
   */
  venue?: VenueOpen | undefined;
  /**
   * Denotes that this trade was either when_issued or when_distributed.
   */
  whenIssued?: WhenIssuedOpen | undefined;
};

/** @internal */
export const TradeCreateAssetType$inboundSchema: z.ZodType<
  TradeCreateAssetTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(TradeCreateAssetType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const TradeCreateAssetType$outboundSchema: z.ZodType<
  TradeCreateAssetTypeOpen,
  z.ZodTypeDef,
  TradeCreateAssetTypeOpen
> = z.union([
  z.nativeEnum(TradeCreateAssetType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TradeCreateAssetType$ {
  /** @deprecated use `TradeCreateAssetType$inboundSchema` instead. */
  export const inboundSchema = TradeCreateAssetType$inboundSchema;
  /** @deprecated use `TradeCreateAssetType$outboundSchema` instead. */
  export const outboundSchema = TradeCreateAssetType$outboundSchema;
}

/** @internal */
export const TradeCreateBrokerCapacity$inboundSchema: z.ZodType<
  TradeCreateBrokerCapacityOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(TradeCreateBrokerCapacity),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const TradeCreateBrokerCapacity$outboundSchema: z.ZodType<
  TradeCreateBrokerCapacityOpen,
  z.ZodTypeDef,
  TradeCreateBrokerCapacityOpen
> = z.union([
  z.nativeEnum(TradeCreateBrokerCapacity),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TradeCreateBrokerCapacity$ {
  /** @deprecated use `TradeCreateBrokerCapacity$inboundSchema` instead. */
  export const inboundSchema = TradeCreateBrokerCapacity$inboundSchema;
  /** @deprecated use `TradeCreateBrokerCapacity$outboundSchema` instead. */
  export const outboundSchema = TradeCreateBrokerCapacity$outboundSchema;
}

/** @internal */
export const TradeCreateIdentifierType$inboundSchema: z.ZodType<
  TradeCreateIdentifierTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(TradeCreateIdentifierType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const TradeCreateIdentifierType$outboundSchema: z.ZodType<
  TradeCreateIdentifierTypeOpen,
  z.ZodTypeDef,
  TradeCreateIdentifierTypeOpen
> = z.union([
  z.nativeEnum(TradeCreateIdentifierType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TradeCreateIdentifierType$ {
  /** @deprecated use `TradeCreateIdentifierType$inboundSchema` instead. */
  export const inboundSchema = TradeCreateIdentifierType$inboundSchema;
  /** @deprecated use `TradeCreateIdentifierType$outboundSchema` instead. */
  export const outboundSchema = TradeCreateIdentifierType$outboundSchema;
}

/** @internal */
export const RouteType$inboundSchema: z.ZodType<
  RouteTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(RouteType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const RouteType$outboundSchema: z.ZodType<
  RouteTypeOpen,
  z.ZodTypeDef,
  RouteTypeOpen
> = z.union([
  z.nativeEnum(RouteType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RouteType$ {
  /** @deprecated use `RouteType$inboundSchema` instead. */
  export const inboundSchema = RouteType$inboundSchema;
  /** @deprecated use `RouteType$outboundSchema` instead. */
  export const outboundSchema = RouteType$outboundSchema;
}

/** @internal */
export const TradeCreateSide$inboundSchema: z.ZodType<
  TradeCreateSideOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(TradeCreateSide),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const TradeCreateSide$outboundSchema: z.ZodType<
  TradeCreateSideOpen,
  z.ZodTypeDef,
  TradeCreateSideOpen
> = z.union([
  z.nativeEnum(TradeCreateSide),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TradeCreateSide$ {
  /** @deprecated use `TradeCreateSide$inboundSchema` instead. */
  export const inboundSchema = TradeCreateSide$inboundSchema;
  /** @deprecated use `TradeCreateSide$outboundSchema` instead. */
  export const outboundSchema = TradeCreateSide$outboundSchema;
}

/** @internal */
export const SideModifier$inboundSchema: z.ZodType<
  SideModifierOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(SideModifier),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const SideModifier$outboundSchema: z.ZodType<
  SideModifierOpen,
  z.ZodTypeDef,
  SideModifierOpen
> = z.union([
  z.nativeEnum(SideModifier),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SideModifier$ {
  /** @deprecated use `SideModifier$inboundSchema` instead. */
  export const inboundSchema = SideModifier$inboundSchema;
  /** @deprecated use `SideModifier$outboundSchema` instead. */
  export const outboundSchema = SideModifier$outboundSchema;
}

/** @internal */
export const SpecialInstructions$inboundSchema: z.ZodType<
  SpecialInstructionsOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(SpecialInstructions),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const SpecialInstructions$outboundSchema: z.ZodType<
  SpecialInstructionsOpen,
  z.ZodTypeDef,
  SpecialInstructionsOpen
> = z.union([
  z.nativeEnum(SpecialInstructions),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SpecialInstructions$ {
  /** @deprecated use `SpecialInstructions$inboundSchema` instead. */
  export const inboundSchema = SpecialInstructions$inboundSchema;
  /** @deprecated use `SpecialInstructions$outboundSchema` instead. */
  export const outboundSchema = SpecialInstructions$outboundSchema;
}

/** @internal */
export const Venue$inboundSchema: z.ZodType<VenueOpen, z.ZodTypeDef, unknown> =
  z
    .union([
      z.nativeEnum(Venue),
      z.string().transform(catchUnrecognizedEnum),
    ]);

/** @internal */
export const Venue$outboundSchema: z.ZodType<
  VenueOpen,
  z.ZodTypeDef,
  VenueOpen
> = z.union([
  z.nativeEnum(Venue),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Venue$ {
  /** @deprecated use `Venue$inboundSchema` instead. */
  export const inboundSchema = Venue$inboundSchema;
  /** @deprecated use `Venue$outboundSchema` instead. */
  export const outboundSchema = Venue$outboundSchema;
}

/** @internal */
export const WhenIssued$inboundSchema: z.ZodType<
  WhenIssuedOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(WhenIssued),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const WhenIssued$outboundSchema: z.ZodType<
  WhenIssuedOpen,
  z.ZodTypeDef,
  WhenIssuedOpen
> = z.union([
  z.nativeEnum(WhenIssued),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WhenIssued$ {
  /** @deprecated use `WhenIssued$inboundSchema` instead. */
  export const inboundSchema = WhenIssued$inboundSchema;
  /** @deprecated use `WhenIssued$outboundSchema` instead. */
  export const outboundSchema = WhenIssued$outboundSchema;
}

/** @internal */
export const TradeCreate$inboundSchema: z.ZodType<
  TradeCreate,
  z.ZodTypeDef,
  unknown
> = z.object({
  account_id: z.string(),
  additional_instructions: z.string().optional(),
  alternate_order_id: z.string().optional(),
  asset_type: TradeCreateAssetType$inboundSchema.optional(),
  broker_capacity: TradeCreateBrokerCapacity$inboundSchema,
  client_order_id: z.string(),
  executing_broker: z.string().optional(),
  executions: z.array(ExecutionCreate$inboundSchema),
  fees: z.array(FeeCreate$inboundSchema).optional(),
  identifier: z.string(),
  identifier_type: TradeCreateIdentifierType$inboundSchema,
  issuing_region_code: z.string().optional(),
  local_market_trade_date: DateCreate$inboundSchema.optional(),
  lot_matching_instructions: z.array(LotCreate$inboundSchema).optional(),
  mic_code: z.string().optional(),
  open: z.boolean().optional(),
  order_id: z.string().optional(),
  route_type: RouteType$inboundSchema,
  settlement_date: DateCreate$inboundSchema.optional(),
  side: TradeCreateSide$inboundSchema,
  side_modifier: SideModifier$inboundSchema.optional(),
  source_application: z.string(),
  special_instructions: z.array(SpecialInstructions$inboundSchema).optional(),
  venue: Venue$inboundSchema.optional(),
  when_issued: WhenIssued$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "account_id": "accountId",
    "additional_instructions": "additionalInstructions",
    "alternate_order_id": "alternateOrderId",
    "asset_type": "assetType",
    "broker_capacity": "brokerCapacity",
    "client_order_id": "clientOrderId",
    "executing_broker": "executingBroker",
    "identifier_type": "identifierType",
    "issuing_region_code": "issuingRegionCode",
    "local_market_trade_date": "localMarketTradeDate",
    "lot_matching_instructions": "lotMatchingInstructions",
    "mic_code": "micCode",
    "order_id": "orderId",
    "route_type": "routeType",
    "settlement_date": "settlementDate",
    "side_modifier": "sideModifier",
    "source_application": "sourceApplication",
    "special_instructions": "specialInstructions",
    "when_issued": "whenIssued",
  });
});

/** @internal */
export type TradeCreate$Outbound = {
  account_id: string;
  additional_instructions?: string | undefined;
  alternate_order_id?: string | undefined;
  asset_type?: string | undefined;
  broker_capacity: string;
  client_order_id: string;
  executing_broker?: string | undefined;
  executions: Array<ExecutionCreate$Outbound>;
  fees?: Array<FeeCreate$Outbound> | undefined;
  identifier: string;
  identifier_type: string;
  issuing_region_code?: string | undefined;
  local_market_trade_date?: DateCreate$Outbound | undefined;
  lot_matching_instructions?: Array<LotCreate$Outbound> | undefined;
  mic_code?: string | undefined;
  open?: boolean | undefined;
  order_id?: string | undefined;
  route_type: string;
  settlement_date?: DateCreate$Outbound | undefined;
  side: string;
  side_modifier?: string | undefined;
  source_application: string;
  special_instructions?: Array<string> | undefined;
  venue?: string | undefined;
  when_issued?: string | undefined;
};

/** @internal */
export const TradeCreate$outboundSchema: z.ZodType<
  TradeCreate$Outbound,
  z.ZodTypeDef,
  TradeCreate
> = z.object({
  accountId: z.string(),
  additionalInstructions: z.string().optional(),
  alternateOrderId: z.string().optional(),
  assetType: TradeCreateAssetType$outboundSchema.optional(),
  brokerCapacity: TradeCreateBrokerCapacity$outboundSchema,
  clientOrderId: z.string(),
  executingBroker: z.string().optional(),
  executions: z.array(ExecutionCreate$outboundSchema),
  fees: z.array(FeeCreate$outboundSchema).optional(),
  identifier: z.string(),
  identifierType: TradeCreateIdentifierType$outboundSchema,
  issuingRegionCode: z.string().optional(),
  localMarketTradeDate: DateCreate$outboundSchema.optional(),
  lotMatchingInstructions: z.array(LotCreate$outboundSchema).optional(),
  micCode: z.string().optional(),
  open: z.boolean().optional(),
  orderId: z.string().optional(),
  routeType: RouteType$outboundSchema,
  settlementDate: DateCreate$outboundSchema.optional(),
  side: TradeCreateSide$outboundSchema,
  sideModifier: SideModifier$outboundSchema.optional(),
  sourceApplication: z.string(),
  specialInstructions: z.array(SpecialInstructions$outboundSchema).optional(),
  venue: Venue$outboundSchema.optional(),
  whenIssued: WhenIssued$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    accountId: "account_id",
    additionalInstructions: "additional_instructions",
    alternateOrderId: "alternate_order_id",
    assetType: "asset_type",
    brokerCapacity: "broker_capacity",
    clientOrderId: "client_order_id",
    executingBroker: "executing_broker",
    identifierType: "identifier_type",
    issuingRegionCode: "issuing_region_code",
    localMarketTradeDate: "local_market_trade_date",
    lotMatchingInstructions: "lot_matching_instructions",
    micCode: "mic_code",
    orderId: "order_id",
    routeType: "route_type",
    settlementDate: "settlement_date",
    sideModifier: "side_modifier",
    sourceApplication: "source_application",
    specialInstructions: "special_instructions",
    whenIssued: "when_issued",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TradeCreate$ {
  /** @deprecated use `TradeCreate$inboundSchema` instead. */
  export const inboundSchema = TradeCreate$inboundSchema;
  /** @deprecated use `TradeCreate$outboundSchema` instead. */
  export const outboundSchema = TradeCreate$outboundSchema;
  /** @deprecated use `TradeCreate$Outbound` instead. */
  export type Outbound = TradeCreate$Outbound;
}
