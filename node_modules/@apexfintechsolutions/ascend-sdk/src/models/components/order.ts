/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import {
  catchUnrecognizedEnum,
  OpenEnum,
  Unrecognized,
} from "../../types/enums.js";
import {
  ExecutedPrice,
  ExecutedPrice$inboundSchema,
  ExecutedPrice$Outbound,
  ExecutedPrice$outboundSchema,
} from "./executedprice.js";
import {
  Executions,
  Executions$inboundSchema,
  Executions$Outbound,
  Executions$outboundSchema,
} from "./executions.js";
import {
  Fee,
  Fee$inboundSchema,
  Fee$Outbound,
  Fee$outboundSchema,
} from "./fee.js";

/**
 * The type of the asset in this order, which must be one of the following:
 *
 * @remarks
 *  EQUITY, MUTUAL_FUND, and FIXED_INCOME.
 */
export enum OrderAssetType {
  Equity = "EQUITY",
  FixedIncome = "FIXED_INCOME",
  MutualFund = "MUTUAL_FUND",
}
/**
 * The type of the asset in this order, which must be one of the following:
 *
 * @remarks
 *  EQUITY, MUTUAL_FUND, and FIXED_INCOME.
 */
export type OrderAssetTypeOpen = OpenEnum<typeof OrderAssetType>;

/**
 * Defaults to "AGENCY" if not specified. For Equities: Only "AGENCY" is allowed. For Mutual Funds: Only "AGENCY" is allowed. For Fixed Income: Either "AGENCY" or "PRINCIPAL" are allowed.
 */
export enum OrderBrokerCapacity {
  BrokerCapacityUnspecified = "BROKER_CAPACITY_UNSPECIFIED",
  Agency = "AGENCY",
  Principal = "PRINCIPAL",
}
/**
 * Defaults to "AGENCY" if not specified. For Equities: Only "AGENCY" is allowed. For Mutual Funds: Only "AGENCY" is allowed. For Fixed Income: Either "AGENCY" or "PRINCIPAL" are allowed.
 */
export type OrderBrokerCapacityOpen = OpenEnum<typeof OrderBrokerCapacity>;

/**
 * Used to denote when a cancel request has been rejected.
 */
export enum CancelRejectedReason {
  CancelRejectReasonUnspecified = "CANCEL_REJECT_REASON_UNSPECIFIED",
  TooLateToCancel = "TOO_LATE_TO_CANCEL",
  CancellationUnknownOrder = "CANCELLATION_UNKNOWN_ORDER",
  BrokerExchangeOption = "BROKER_EXCHANGE_OPTION",
  OrderAlreadyInPendingCancelOrPendingReplaceStatus =
    "ORDER_ALREADY_IN_PENDING_CANCEL_OR_PENDING_REPLACE_STATUS",
  Duplicate = "DUPLICATE",
  CancellationSystemError = "CANCELLATION_SYSTEM_ERROR",
  OrderAlreadyCanceled = "ORDER_ALREADY_CANCELED",
  CancellationMisconfiguredClient = "CANCELLATION_MISCONFIGURED_CLIENT",
}
/**
 * Used to denote when a cancel request has been rejected.
 */
export type CancelRejectedReasonOpen = OpenEnum<typeof CancelRejectedReason>;

/**
 * The type of commission value being specified. Only the type of "AMOUNT" is supported.
 */
export enum OrderCommissionType {
  CommissionTypeUnspecified = "COMMISSION_TYPE_UNSPECIFIED",
  Amount = "AMOUNT",
}
/**
 * The type of commission value being specified. Only the type of "AMOUNT" is supported.
 */
export type OrderCommissionTypeOpen = OpenEnum<typeof OrderCommissionType>;

/**
 * The value of this commission. If type = `AMOUNT`, then this expresses a monetary value in same currency denoted on the order itself.
 */
export type Value = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * A custom commission to be applied to this order. When specifying an AMOUNT type, the value represents a notional amount measured in the currency of the order.
 */
export type OrderCommission = {
  /**
   * The type of commission value being specified. Only the type of "AMOUNT" is supported.
   */
  type?: OrderCommissionTypeOpen | undefined;
  /**
   * The value of this commission. If type = `AMOUNT`, then this expresses a monetary value in same currency denoted on the order itself.
   */
  value?: Value | null | undefined;
};

/**
 * The sum of order quantity & price, across all fills, reported in the currency specified in the order. (This will be rounded to 2 decimal places for USD currencies). Will be absent if an order has no fill information.
 */
export type CumulativeNotionalValue = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * The summed quantity value across all fills in this order, up to a maximum of 5 decimal places. Will be absent if an order has no fill information.
 */
export type FilledQuantity = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * The identifier type of the asset being ordered. For Equities: only SYMBOL is supported For Mutual Funds: only SYMBOL and CUSIP are supported For Fixed Income: only CUSIP and ISIN are supported
 */
export enum OrderIdentifierType {
  Symbol = "SYMBOL",
  Cusip = "CUSIP",
  Isin = "ISIN",
}
/**
 * The identifier type of the asset being ordered. For Equities: only SYMBOL is supported For Mutual Funds: only SYMBOL and CUSIP are supported For Fixed Income: only CUSIP and ISIN are supported
 */
export type OrderIdentifierTypeOpen = OpenEnum<typeof OrderIdentifierType>;

/**
 * The amount of the LOI. This is a monetary value in the same currency as the order.
 */
export type OrderAmount = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * The period start date, specific to the US Eastern Time Zone, of the LOI. Date range: 90 days in the past and 13 months in the future from the order_date.
 */
export type PeriodStartDate = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * Letter of Intent (LOI). An LOI allows investors to receive sales charge discounts based on a commitment to buy a specified monetary amount of shares over a period of time, usually 13 months.
 */
export type LetterOfIntent = {
  /**
   * The amount of the LOI. This is a monetary value in the same currency as the order.
   */
  amount?: OrderAmount | null | undefined;
  /**
   * The period start date, specific to the US Eastern Time Zone, of the LOI. Date range: 90 days in the past and 13 months in the future from the order_date.
   */
  periodStartDate?: PeriodStartDate | null | undefined;
};

/**
 * The limit price which must be greater than zero if provided. For equity orders in the USD currency, up to 2 decimal places are allowed for prices above $1 and up to 4 decimal places for prices at or below $1. For fixed income orders this is expressed as a percentage of par, which allows up to 4 decimal places in the USD currency.
 */
export type OrderPrice = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * The type of this price, which must be PRICE_PER_UNIT for equity orders, or PERCENTAGE_OF_PAR for fixed income orders.
 */
export enum OrderLimitPriceType {
  LimitPriceTypeUnspecified = "LIMIT_PRICE_TYPE_UNSPECIFIED",
  PricePerUnit = "PRICE_PER_UNIT",
  PercentageOfPar = "PERCENTAGE_OF_PAR",
}
/**
 * The type of this price, which must be PRICE_PER_UNIT for equity orders, or PERCENTAGE_OF_PAR for fixed income orders.
 */
export type OrderLimitPriceTypeOpen = OpenEnum<typeof OrderLimitPriceType>;

/**
 * The limit price for this order.
 */
export type LimitPrice = {
  /**
   * The limit price which must be greater than zero if provided. For equity orders in the USD currency, up to 2 decimal places are allowed for prices above $1 and up to 4 decimal places for prices at or below $1. For fixed income orders this is expressed as a percentage of par, which allows up to 4 decimal places in the USD currency.
   */
  price?: OrderPrice | null | undefined;
  /**
   * The type of this price, which must be PRICE_PER_UNIT for equity orders, or PERCENTAGE_OF_PAR for fixed income orders.
   */
  type?: OrderLimitPriceTypeOpen | undefined;
};

/**
 * The maximum number of shares to be sold if this is a notional SELL order of an Equity asset type. (Prohibited for other side or asset_type inputs.)
 *
 * @remarks
 *
 *  This will only be recognized for clients configured not to use OMS checks. When specified, must be greater than 0 and can't exceed 5 decimal places.
 */
export type MaxSellQuantity = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Notional quantity of the order, measured in USD. Maximum 2 decimal place precision. For Equities: This represents the maximum amount to be spent. The final order may may have a smaller notional amount. For Mutual Funds: Only supported for BUY orders. The order will be transacted at the full notional amount specified. For Fixed Income: Not supported, you must specify a `quantity` value.
 */
export type NotionalValue = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * The date on which the order will go to the market: must either be "today" or the next valid trading day. If the current day is not a valid trading day, then the next valid market day must be specified. If the current time is within 5 minutes prior to market close, the next valid market day may be specified. If the current time is after market close, and before midnight Eastern, then the next valid market day must be specified. In all other cases, the current day, Eastern must be specified.
 */
export type OrderDate = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * When an order has the REJECTED status, this will be populated with a system code describing the rejection.
 */
export enum OrderRejectedReason {
  OrderRejectReasonUnspecified = "ORDER_REJECT_REASON_UNSPECIFIED",
  BrokerOption = "BROKER_OPTION",
  UnknownSecurity = "UNKNOWN_SECURITY",
  ExchangeClosed = "EXCHANGE_CLOSED",
  OrderExceedsLimit = "ORDER_EXCEEDS_LIMIT",
  TooLateToEnter = "TOO_LATE_TO_ENTER",
  UnknownOrder = "UNKNOWN_ORDER",
  DuplicateOrder = "DUPLICATE_ORDER",
  StaleOrder = "STALE_ORDER",
  BelowNotionalMinimum = "BELOW_NOTIONAL_MINIMUM",
  OrderDateUnavailable = "ORDER_DATE_UNAVAILABLE",
  AggressiveLimitPrice = "AGGRESSIVE_LIMIT_PRICE",
  AccountNotEntitled = "ACCOUNT_NOT_ENTITLED",
  SystemError = "SYSTEM_ERROR",
  BlockingCorporateAction = "BLOCKING_CORPORATE_ACTION",
  UnavailablePriceQuote = "UNAVAILABLE_PRICE_QUOTE",
  ExecutionMisconfiguredClient = "EXECUTION_MISCONFIGURED_CLIENT",
  NotionalQuantityNotAllowedForSecurity =
    "NOTIONAL_QUANTITY_NOT_ALLOWED_FOR_SECURITY",
  FractionalQuantityNotAllowedForSecurity =
    "FRACTIONAL_QUANTITY_NOT_ALLOWED_FOR_SECURITY",
  OnlyFractionalSellOrWholeOrdersAllowedForSecurity =
    "ONLY_FRACTIONAL_SELL_OR_WHOLE_ORDERS_ALLOWED_FOR_SECURITY",
  SymbolNotTradeable = "SYMBOL_NOT_TRADEABLE",
  AboveNotionalMaximum = "ABOVE_NOTIONAL_MAXIMUM",
  AboveShareMaximum = "ABOVE_SHARE_MAXIMUM",
  FailedBuyingPower = "FAILED_BUYING_POWER",
  InsufficientPosition = "INSUFFICIENT_POSITION",
  MaxSellQuantityRequired = "MAX_SELL_QUANTITY_REQUIRED",
  MaxSellQuantityProhibited = "MAX_SELL_QUANTITY_PROHIBITED",
  StopPriceExceedsMarketPrice = "STOP_PRICE_EXCEEDS_MARKET_PRICE",
  TradesDisabledForAssetType = "TRADES_DISABLED_FOR_ASSET_TYPE",
  CommissionNotAllowedForNonBrokerDealer =
    "COMMISSION_NOT_ALLOWED_FOR_NON_BROKER_DEALER",
  AssetNotSetUpToTrade = "ASSET_NOT_SET_UP_TO_TRADE",
  InvalidOrderQuantity = "INVALID_ORDER_QUANTITY",
  ClientReceivedTimeRequired = "CLIENT_RECEIVED_TIME_REQUIRED",
}
/**
 * When an order has the REJECTED status, this will be populated with a system code describing the rejection.
 */
export type OrderRejectedReasonOpen = OpenEnum<typeof OrderRejectedReason>;

/**
 * The processing status of the order
 */
export enum OrderStatus {
  OrderStatusUnspecified = "ORDER_STATUS_UNSPECIFIED",
  PendingNew = "PENDING_NEW",
  New = "NEW",
  PendingQueued = "PENDING_QUEUED",
  Queued = "QUEUED",
  PartiallyFilled = "PARTIALLY_FILLED",
  Filled = "FILLED",
  PendingCancel = "PENDING_CANCEL",
  Canceled = "CANCELED",
  Rejected = "REJECTED",
}
/**
 * The processing status of the order
 */
export type OrderStatusOpen = OpenEnum<typeof OrderStatus>;

/**
 * The execution type of this order. For Equities: MARKET, LIMIT, or STOP are supported. For Mutual Funds: only MARKET is supported. For Fixed Income: only LIMIT is supported.
 */
export enum OrderOrderType {
  OrderTypeUnspecified = "ORDER_TYPE_UNSPECIFIED",
  Limit = "LIMIT",
  Market = "MARKET",
  Stop = "STOP",
}
/**
 * The execution type of this order. For Equities: MARKET, LIMIT, or STOP are supported. For Mutual Funds: only MARKET is supported. For Fixed Income: only LIMIT is supported.
 */
export type OrderOrderTypeOpen = OpenEnum<typeof OrderOrderType>;

/**
 * The prevailing market price, calculated as a weighted average of the fills in this order, up to a maximum of 5 decimal places. Will be absent if an order has no executions.
 */
export type OrderPrevailingMarketPrice = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Numeric quantity of the order. For Equities: Represents the number of shares, must be greater than zero and may not exceed 5 decimal places. For Mutual Funds: Only supported for SELL orders. Represents the number of shares, up to a maximum of 3 decimal places. For Fixed Income: Represents the par (face-value) amount being ordered, and may not exceed two decimal places for USD-based currencies. Either a quantity or notional_value MUST be specified (but not both).
 */
export type OrderQuantity = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * The amount of the ROA. This is a monetary value in the same currency as the order. Only 9999999.99 is supported.
 */
export type OrderRightsOfAccumulationAmount = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Rights of Accumulation (ROA). An ROA allows an investor to aggregate their own fund shares with the holdings of certain related parties toward achieving the investment thresholds at which sales charge discounts become available.
 */
export type RightsOfAccumulation = {
  /**
   * The amount of the ROA. This is a monetary value in the same currency as the order. Only 9999999.99 is supported.
   */
  amount?: OrderRightsOfAccumulationAmount | null | undefined;
};

/**
 * The side of this order.
 */
export enum OrderSide {
  SideUnspecified = "SIDE_UNSPECIFIED",
  Buy = "BUY",
  Sell = "SELL",
}
/**
 * The side of this order.
 */
export type OrderSideOpen = OpenEnum<typeof OrderSide>;

export enum OrderSpecialReportingInstructions {
  SpecialReportingInstructionsUnspecified =
    "SPECIAL_REPORTING_INSTRUCTIONS_UNSPECIFIED",
  CustomerDirected = "CUSTOMER_DIRECTED",
  WithDividend = "WITH_DIVIDEND",
  WithRights = "WITH_RIGHTS",
  DiscretionExercised = "DISCRETION_EXERCISED",
  DiscretionNotExercised = "DISCRETION_NOT_EXERCISED",
  BrokerDealerOrder = "BROKER_DEALER_ORDER",
  FullyRegistered = "FULLY_REGISTERED",
  OddlotDiffOnRequest = "ODDLOT_DIFF_ON_REQUEST",
  ProspectusEnclosed = "PROSPECTUS_ENCLOSED",
  ProspectusSeparateMail = "PROSPECTUS_SEPARATE_MAIL",
  Solicited = "SOLICITED",
  Unsolicited = "UNSOLICITED",
  XDividend = "X_DIVIDEND",
  ActingAsPrincipal = "ACTING_AS_PRINCIPAL",
  AveragePrice = "AVERAGE_PRICE",
  BrokerLiquidation = "BROKER_LIQUIDATION",
  InternetOrder = "INTERNET_ORDER",
  MarginSellout = "MARGIN_SELLOUT",
  NegativeNetProceed = "NEGATIVE_NET_PROCEED",
  RisklessPrincipal = "RISKLESS_PRINCIPAL",
  ThirdMarket = "THIRD_MARKET",
  SuppressTraceReporting = "SUPPRESS_TRACE_REPORTING",
  WhenDistributed = "WHEN_DISTRIBUTED",
}
export type OrderSpecialReportingInstructionsOpen = OpenEnum<
  typeof OrderSpecialReportingInstructions
>;

/**
 * The stop price which must be greater than zero if provided. For equity orders in the USD currency, up to 2 decimal places are allowed for prices above $1 and up to 4 decimal places for prices at or below $1.
 */
export type OrderStopPricePrice = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * The type of this price, which must PRICE_PER_UNIT for equity orders. (Fixed income and mutual fund assets do not support stop orders.)
 */
export enum OrderStopPriceType {
  StopPriceTypeUnspecified = "STOP_PRICE_TYPE_UNSPECIFIED",
  PricePerUnit = "PRICE_PER_UNIT",
}
/**
 * The type of this price, which must PRICE_PER_UNIT for equity orders. (Fixed income and mutual fund assets do not support stop orders.)
 */
export type OrderStopPriceTypeOpen = OpenEnum<typeof OrderStopPriceType>;

/**
 * The stop price for this order. Only allowed for equities, when the side is SELL.
 */
export type StopPrice = {
  /**
   * The stop price which must be greater than zero if provided. For equity orders in the USD currency, up to 2 decimal places are allowed for prices above $1 and up to 4 decimal places for prices at or below $1.
   */
  price?: OrderStopPricePrice | null | undefined;
  /**
   * The type of this price, which must PRICE_PER_UNIT for equity orders. (Fixed income and mutual fund assets do not support stop orders.)
   */
  type?: OrderStopPriceTypeOpen | undefined;
};

/**
 * Must be the value "DAY". Regulatory requirements dictate that the system capture the intended time_in_force, which is why this a mandatory field.
 */
export enum OrderTimeInForce {
  TimeInForceUnspecified = "TIME_IN_FORCE_UNSPECIFIED",
  Day = "DAY",
}
/**
 * Must be the value "DAY". Regulatory requirements dictate that the system capture the intended time_in_force, which is why this a mandatory field.
 */
export type OrderTimeInForceOpen = OpenEnum<typeof OrderTimeInForce>;

/**
 * The message describing an order
 */
export type Order = {
  /**
   * The identifier of the account transacting this order
   */
  accountId?: string | undefined;
  /**
   * Apex Asset ID for this asset. This will not be returned in the initial CreateOrder response and will be available after an order completes validation. If the provided identifier does not match any Apex asset available for trading, an OrderRejectReason of "UNKNOWN_SECURITY" will be returned and the asset_id will not be set.
   */
  assetId?: string | undefined;
  /**
   * The type of the asset in this order, which must be one of the following:
   *
   * @remarks
   *  EQUITY, MUTUAL_FUND, and FIXED_INCOME.
   */
  assetType?: OrderAssetTypeOpen | undefined;
  /**
   * The average prices, as weighted averages, across all executions in this order. Will be absent if an order has no executions.
   *
   * @remarks
   *
   *  When asset_type = EQUITY or MUTUAL_FUND, there will be at most one value present, with a type of PRICE_PER_UNIT. This will have up to 4 decimal places for USD amounts less than $1, and a maximum of two for larger USD amounts.
   *
   *  When asset_type = FIXED_INCOME, there may be more than one value present which would have a type other than PRICE_PER_UNIT. Price values in PERCENTAGE_OF_PAR will have up to 4 decimal places of precision, and price values measured in yields will support up to 5 decimal places.
   */
  averagePrices?: Array<ExecutedPrice> | undefined;
  /**
   * Defaults to "AGENCY" if not specified. For Equities: Only "AGENCY" is allowed. For Mutual Funds: Only "AGENCY" is allowed. For Fixed Income: Either "AGENCY" or "PRINCIPAL" are allowed.
   */
  brokerCapacity?: OrderBrokerCapacityOpen | undefined;
  /**
   * Used to explain why an order is canceled
   */
  cancelReason?: string | undefined;
  /**
   * Used to denote when a cancel request has been rejected.
   */
  cancelRejectedReason?: CancelRejectedReasonOpen | undefined;
  /**
   * User-supplied unique order ID. Cannot be more than 40 characters long.
   */
  clientOrderId?: string | undefined;
  /**
   * Required for Equity Orders for any client who is having Apex do CAT reporting on their behalf. A value may be provided for non-Equity orders, and will be remembered, but valid timestamps will have no impact on how they are processed.
   */
  clientReceivedTime?: Date | null | undefined;
  /**
   * A custom commission to be applied to this order. When specifying an AMOUNT type, the value represents a notional amount measured in the currency of the order.
   */
  commission?: OrderCommission | null | undefined;
  /**
   * Time of the order creation
   */
  createTime?: Date | null | undefined;
  /**
   * The sum of order quantity & price, across all fills, reported in the currency specified in the order. (This will be rounded to 2 decimal places for USD currencies). Will be absent if an order has no fill information.
   */
  cumulativeNotionalValue?: CumulativeNotionalValue | null | undefined;
  /**
   * Defaults to "USD". Only "USD" is supported. Full list of currency codes is defined at: https://en.wikipedia.org/wiki/ISO_4217
   */
  currencyCode?: string | undefined;
  /**
   * The execution-level details that compose this order
   */
  executions?: Array<Executions> | undefined;
  /**
   * Fees that will be applied to this order. Only the BROKER_FEE type is supported.
   */
  fees?: Array<Fee> | undefined;
  /**
   * The summed quantity value across all fills in this order, up to a maximum of 5 decimal places. Will be absent if an order has no fill information.
   */
  filledQuantity?: FilledQuantity | null | undefined;
  /**
   * Identifier of the asset (of the type specified in `identifier_type`).
   */
  identifier?: string | undefined;
  /**
   * A string attribute denoting the country of issuance or where the asset is trading. Only available for Mutual Fund orders. Defaults to US, when trading non US mutual funds this field must be provided Complies with ISO-3166 Alpha-2 Codes
   */
  identifierIssuingRegionCode?: string | undefined;
  /**
   * The identifier type of the asset being ordered. For Equities: only SYMBOL is supported For Mutual Funds: only SYMBOL and CUSIP are supported For Fixed Income: only CUSIP and ISIN are supported
   */
  identifierType?: OrderIdentifierTypeOpen | undefined;
  /**
   * Time of the last order update
   */
  lastUpdateTime?: Date | null | undefined;
  /**
   * Letter of Intent (LOI). An LOI allows investors to receive sales charge discounts based on a commitment to buy a specified monetary amount of shares over a period of time, usually 13 months.
   */
  letterOfIntent?: LetterOfIntent | null | undefined;
  /**
   * The limit price for this order.
   */
  limitPrice?: LimitPrice | null | undefined;
  /**
   * The maximum number of shares to be sold if this is a notional SELL order of an Equity asset type. (Prohibited for other side or asset_type inputs.)
   *
   * @remarks
   *
   *  This will only be recognized for clients configured not to use OMS checks. When specified, must be greater than 0 and can't exceed 5 decimal places.
   */
  maxSellQuantity?: MaxSellQuantity | null | undefined;
  /**
   * System generated name of the order.
   */
  name?: string | undefined;
  /**
   * Notional quantity of the order, measured in USD. Maximum 2 decimal place precision. For Equities: This represents the maximum amount to be spent. The final order may may have a smaller notional amount. For Mutual Funds: Only supported for BUY orders. The order will be transacted at the full notional amount specified. For Fixed Income: Not supported, you must specify a `quantity` value.
   */
  notionalValue?: NotionalValue | null | undefined;
  /**
   * The date on which the order will go to the market: must either be "today" or the next valid trading day. If the current day is not a valid trading day, then the next valid market day must be specified. If the current time is within 5 minutes prior to market close, the next valid market day may be specified. If the current time is after market close, and before midnight Eastern, then the next valid market day must be specified. In all other cases, the current day, Eastern must be specified.
   */
  orderDate?: OrderDate | null | undefined;
  /**
   * System generated unique id for the order.
   */
  orderId?: string | undefined;
  /**
   * When an order has the REJECTED status, this will be populated with a system code describing the rejection.
   */
  orderRejectedReason?: OrderRejectedReasonOpen | undefined;
  /**
   * The processing status of the order
   */
  orderStatus?: OrderStatusOpen | undefined;
  /**
   * The execution type of this order. For Equities: MARKET, LIMIT, or STOP are supported. For Mutual Funds: only MARKET is supported. For Fixed Income: only LIMIT is supported.
   */
  orderType?: OrderOrderTypeOpen | undefined;
  /**
   * The prevailing market price, calculated as a weighted average of the fills in this order, up to a maximum of 5 decimal places. Will be absent if an order has no executions.
   */
  prevailingMarketPrice?: OrderPrevailingMarketPrice | null | undefined;
  /**
   * Numeric quantity of the order. For Equities: Represents the number of shares, must be greater than zero and may not exceed 5 decimal places. For Mutual Funds: Only supported for SELL orders. Represents the number of shares, up to a maximum of 3 decimal places. For Fixed Income: Represents the par (face-value) amount being ordered, and may not exceed two decimal places for USD-based currencies. Either a quantity or notional_value MUST be specified (but not both).
   */
  quantity?: OrderQuantity | null | undefined;
  /**
   * Rights of Accumulation (ROA). An ROA allows an investor to aggregate their own fund shares with the holdings of certain related parties toward achieving the investment thresholds at which sales charge discounts become available.
   */
  rightsOfAccumulation?: RightsOfAccumulation | null | undefined;
  /**
   * The side of this order.
   */
  side?: OrderSideOpen | undefined;
  /**
   * Special Reporting Instructions to be applied to this order. Can include multiple Instructions.
   */
  specialReportingInstructions?:
    | Array<OrderSpecialReportingInstructionsOpen>
    | undefined;
  /**
   * The stop price for this order. Only allowed for equities, when the side is SELL.
   */
  stopPrice?: StopPrice | null | undefined;
  /**
   * Must be the value "DAY". Regulatory requirements dictate that the system capture the intended time_in_force, which is why this a mandatory field.
   */
  timeInForce?: OrderTimeInForceOpen | undefined;
};

/** @internal */
export const OrderAssetType$inboundSchema: z.ZodType<
  OrderAssetTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OrderAssetType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OrderAssetType$outboundSchema: z.ZodType<
  OrderAssetTypeOpen,
  z.ZodTypeDef,
  OrderAssetTypeOpen
> = z.union([
  z.nativeEnum(OrderAssetType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OrderAssetType$ {
  /** @deprecated use `OrderAssetType$inboundSchema` instead. */
  export const inboundSchema = OrderAssetType$inboundSchema;
  /** @deprecated use `OrderAssetType$outboundSchema` instead. */
  export const outboundSchema = OrderAssetType$outboundSchema;
}

/** @internal */
export const OrderBrokerCapacity$inboundSchema: z.ZodType<
  OrderBrokerCapacityOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OrderBrokerCapacity),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OrderBrokerCapacity$outboundSchema: z.ZodType<
  OrderBrokerCapacityOpen,
  z.ZodTypeDef,
  OrderBrokerCapacityOpen
> = z.union([
  z.nativeEnum(OrderBrokerCapacity),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OrderBrokerCapacity$ {
  /** @deprecated use `OrderBrokerCapacity$inboundSchema` instead. */
  export const inboundSchema = OrderBrokerCapacity$inboundSchema;
  /** @deprecated use `OrderBrokerCapacity$outboundSchema` instead. */
  export const outboundSchema = OrderBrokerCapacity$outboundSchema;
}

/** @internal */
export const CancelRejectedReason$inboundSchema: z.ZodType<
  CancelRejectedReasonOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(CancelRejectedReason),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const CancelRejectedReason$outboundSchema: z.ZodType<
  CancelRejectedReasonOpen,
  z.ZodTypeDef,
  CancelRejectedReasonOpen
> = z.union([
  z.nativeEnum(CancelRejectedReason),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CancelRejectedReason$ {
  /** @deprecated use `CancelRejectedReason$inboundSchema` instead. */
  export const inboundSchema = CancelRejectedReason$inboundSchema;
  /** @deprecated use `CancelRejectedReason$outboundSchema` instead. */
  export const outboundSchema = CancelRejectedReason$outboundSchema;
}

/** @internal */
export const OrderCommissionType$inboundSchema: z.ZodType<
  OrderCommissionTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OrderCommissionType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OrderCommissionType$outboundSchema: z.ZodType<
  OrderCommissionTypeOpen,
  z.ZodTypeDef,
  OrderCommissionTypeOpen
> = z.union([
  z.nativeEnum(OrderCommissionType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OrderCommissionType$ {
  /** @deprecated use `OrderCommissionType$inboundSchema` instead. */
  export const inboundSchema = OrderCommissionType$inboundSchema;
  /** @deprecated use `OrderCommissionType$outboundSchema` instead. */
  export const outboundSchema = OrderCommissionType$outboundSchema;
}

/** @internal */
export const Value$inboundSchema: z.ZodType<Value, z.ZodTypeDef, unknown> = z
  .object({
    value: z.string().optional(),
  });

/** @internal */
export type Value$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const Value$outboundSchema: z.ZodType<
  Value$Outbound,
  z.ZodTypeDef,
  Value
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Value$ {
  /** @deprecated use `Value$inboundSchema` instead. */
  export const inboundSchema = Value$inboundSchema;
  /** @deprecated use `Value$outboundSchema` instead. */
  export const outboundSchema = Value$outboundSchema;
  /** @deprecated use `Value$Outbound` instead. */
  export type Outbound = Value$Outbound;
}

/** @internal */
export const OrderCommission$inboundSchema: z.ZodType<
  OrderCommission,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: OrderCommissionType$inboundSchema.optional(),
  value: z.nullable(z.lazy(() => Value$inboundSchema)).optional(),
});

/** @internal */
export type OrderCommission$Outbound = {
  type?: string | undefined;
  value?: Value$Outbound | null | undefined;
};

/** @internal */
export const OrderCommission$outboundSchema: z.ZodType<
  OrderCommission$Outbound,
  z.ZodTypeDef,
  OrderCommission
> = z.object({
  type: OrderCommissionType$outboundSchema.optional(),
  value: z.nullable(z.lazy(() => Value$outboundSchema)).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OrderCommission$ {
  /** @deprecated use `OrderCommission$inboundSchema` instead. */
  export const inboundSchema = OrderCommission$inboundSchema;
  /** @deprecated use `OrderCommission$outboundSchema` instead. */
  export const outboundSchema = OrderCommission$outboundSchema;
  /** @deprecated use `OrderCommission$Outbound` instead. */
  export type Outbound = OrderCommission$Outbound;
}

/** @internal */
export const CumulativeNotionalValue$inboundSchema: z.ZodType<
  CumulativeNotionalValue,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type CumulativeNotionalValue$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const CumulativeNotionalValue$outboundSchema: z.ZodType<
  CumulativeNotionalValue$Outbound,
  z.ZodTypeDef,
  CumulativeNotionalValue
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CumulativeNotionalValue$ {
  /** @deprecated use `CumulativeNotionalValue$inboundSchema` instead. */
  export const inboundSchema = CumulativeNotionalValue$inboundSchema;
  /** @deprecated use `CumulativeNotionalValue$outboundSchema` instead. */
  export const outboundSchema = CumulativeNotionalValue$outboundSchema;
  /** @deprecated use `CumulativeNotionalValue$Outbound` instead. */
  export type Outbound = CumulativeNotionalValue$Outbound;
}

/** @internal */
export const FilledQuantity$inboundSchema: z.ZodType<
  FilledQuantity,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type FilledQuantity$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const FilledQuantity$outboundSchema: z.ZodType<
  FilledQuantity$Outbound,
  z.ZodTypeDef,
  FilledQuantity
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FilledQuantity$ {
  /** @deprecated use `FilledQuantity$inboundSchema` instead. */
  export const inboundSchema = FilledQuantity$inboundSchema;
  /** @deprecated use `FilledQuantity$outboundSchema` instead. */
  export const outboundSchema = FilledQuantity$outboundSchema;
  /** @deprecated use `FilledQuantity$Outbound` instead. */
  export type Outbound = FilledQuantity$Outbound;
}

/** @internal */
export const OrderIdentifierType$inboundSchema: z.ZodType<
  OrderIdentifierTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OrderIdentifierType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OrderIdentifierType$outboundSchema: z.ZodType<
  OrderIdentifierTypeOpen,
  z.ZodTypeDef,
  OrderIdentifierTypeOpen
> = z.union([
  z.nativeEnum(OrderIdentifierType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OrderIdentifierType$ {
  /** @deprecated use `OrderIdentifierType$inboundSchema` instead. */
  export const inboundSchema = OrderIdentifierType$inboundSchema;
  /** @deprecated use `OrderIdentifierType$outboundSchema` instead. */
  export const outboundSchema = OrderIdentifierType$outboundSchema;
}

/** @internal */
export const OrderAmount$inboundSchema: z.ZodType<
  OrderAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type OrderAmount$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const OrderAmount$outboundSchema: z.ZodType<
  OrderAmount$Outbound,
  z.ZodTypeDef,
  OrderAmount
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OrderAmount$ {
  /** @deprecated use `OrderAmount$inboundSchema` instead. */
  export const inboundSchema = OrderAmount$inboundSchema;
  /** @deprecated use `OrderAmount$outboundSchema` instead. */
  export const outboundSchema = OrderAmount$outboundSchema;
  /** @deprecated use `OrderAmount$Outbound` instead. */
  export type Outbound = OrderAmount$Outbound;
}

/** @internal */
export const PeriodStartDate$inboundSchema: z.ZodType<
  PeriodStartDate,
  z.ZodTypeDef,
  unknown
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/** @internal */
export type PeriodStartDate$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const PeriodStartDate$outboundSchema: z.ZodType<
  PeriodStartDate$Outbound,
  z.ZodTypeDef,
  PeriodStartDate
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PeriodStartDate$ {
  /** @deprecated use `PeriodStartDate$inboundSchema` instead. */
  export const inboundSchema = PeriodStartDate$inboundSchema;
  /** @deprecated use `PeriodStartDate$outboundSchema` instead. */
  export const outboundSchema = PeriodStartDate$outboundSchema;
  /** @deprecated use `PeriodStartDate$Outbound` instead. */
  export type Outbound = PeriodStartDate$Outbound;
}

/** @internal */
export const LetterOfIntent$inboundSchema: z.ZodType<
  LetterOfIntent,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.nullable(z.lazy(() => OrderAmount$inboundSchema)).optional(),
  period_start_date: z.nullable(z.lazy(() => PeriodStartDate$inboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "period_start_date": "periodStartDate",
  });
});

/** @internal */
export type LetterOfIntent$Outbound = {
  amount?: OrderAmount$Outbound | null | undefined;
  period_start_date?: PeriodStartDate$Outbound | null | undefined;
};

/** @internal */
export const LetterOfIntent$outboundSchema: z.ZodType<
  LetterOfIntent$Outbound,
  z.ZodTypeDef,
  LetterOfIntent
> = z.object({
  amount: z.nullable(z.lazy(() => OrderAmount$outboundSchema)).optional(),
  periodStartDate: z.nullable(z.lazy(() => PeriodStartDate$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    periodStartDate: "period_start_date",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LetterOfIntent$ {
  /** @deprecated use `LetterOfIntent$inboundSchema` instead. */
  export const inboundSchema = LetterOfIntent$inboundSchema;
  /** @deprecated use `LetterOfIntent$outboundSchema` instead. */
  export const outboundSchema = LetterOfIntent$outboundSchema;
  /** @deprecated use `LetterOfIntent$Outbound` instead. */
  export type Outbound = LetterOfIntent$Outbound;
}

/** @internal */
export const OrderPrice$inboundSchema: z.ZodType<
  OrderPrice,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type OrderPrice$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const OrderPrice$outboundSchema: z.ZodType<
  OrderPrice$Outbound,
  z.ZodTypeDef,
  OrderPrice
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OrderPrice$ {
  /** @deprecated use `OrderPrice$inboundSchema` instead. */
  export const inboundSchema = OrderPrice$inboundSchema;
  /** @deprecated use `OrderPrice$outboundSchema` instead. */
  export const outboundSchema = OrderPrice$outboundSchema;
  /** @deprecated use `OrderPrice$Outbound` instead. */
  export type Outbound = OrderPrice$Outbound;
}

/** @internal */
export const OrderLimitPriceType$inboundSchema: z.ZodType<
  OrderLimitPriceTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OrderLimitPriceType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OrderLimitPriceType$outboundSchema: z.ZodType<
  OrderLimitPriceTypeOpen,
  z.ZodTypeDef,
  OrderLimitPriceTypeOpen
> = z.union([
  z.nativeEnum(OrderLimitPriceType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OrderLimitPriceType$ {
  /** @deprecated use `OrderLimitPriceType$inboundSchema` instead. */
  export const inboundSchema = OrderLimitPriceType$inboundSchema;
  /** @deprecated use `OrderLimitPriceType$outboundSchema` instead. */
  export const outboundSchema = OrderLimitPriceType$outboundSchema;
}

/** @internal */
export const LimitPrice$inboundSchema: z.ZodType<
  LimitPrice,
  z.ZodTypeDef,
  unknown
> = z.object({
  price: z.nullable(z.lazy(() => OrderPrice$inboundSchema)).optional(),
  type: OrderLimitPriceType$inboundSchema.optional(),
});

/** @internal */
export type LimitPrice$Outbound = {
  price?: OrderPrice$Outbound | null | undefined;
  type?: string | undefined;
};

/** @internal */
export const LimitPrice$outboundSchema: z.ZodType<
  LimitPrice$Outbound,
  z.ZodTypeDef,
  LimitPrice
> = z.object({
  price: z.nullable(z.lazy(() => OrderPrice$outboundSchema)).optional(),
  type: OrderLimitPriceType$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LimitPrice$ {
  /** @deprecated use `LimitPrice$inboundSchema` instead. */
  export const inboundSchema = LimitPrice$inboundSchema;
  /** @deprecated use `LimitPrice$outboundSchema` instead. */
  export const outboundSchema = LimitPrice$outboundSchema;
  /** @deprecated use `LimitPrice$Outbound` instead. */
  export type Outbound = LimitPrice$Outbound;
}

/** @internal */
export const MaxSellQuantity$inboundSchema: z.ZodType<
  MaxSellQuantity,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type MaxSellQuantity$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const MaxSellQuantity$outboundSchema: z.ZodType<
  MaxSellQuantity$Outbound,
  z.ZodTypeDef,
  MaxSellQuantity
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MaxSellQuantity$ {
  /** @deprecated use `MaxSellQuantity$inboundSchema` instead. */
  export const inboundSchema = MaxSellQuantity$inboundSchema;
  /** @deprecated use `MaxSellQuantity$outboundSchema` instead. */
  export const outboundSchema = MaxSellQuantity$outboundSchema;
  /** @deprecated use `MaxSellQuantity$Outbound` instead. */
  export type Outbound = MaxSellQuantity$Outbound;
}

/** @internal */
export const NotionalValue$inboundSchema: z.ZodType<
  NotionalValue,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type NotionalValue$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const NotionalValue$outboundSchema: z.ZodType<
  NotionalValue$Outbound,
  z.ZodTypeDef,
  NotionalValue
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotionalValue$ {
  /** @deprecated use `NotionalValue$inboundSchema` instead. */
  export const inboundSchema = NotionalValue$inboundSchema;
  /** @deprecated use `NotionalValue$outboundSchema` instead. */
  export const outboundSchema = NotionalValue$outboundSchema;
  /** @deprecated use `NotionalValue$Outbound` instead. */
  export type Outbound = NotionalValue$Outbound;
}

/** @internal */
export const OrderDate$inboundSchema: z.ZodType<
  OrderDate,
  z.ZodTypeDef,
  unknown
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/** @internal */
export type OrderDate$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const OrderDate$outboundSchema: z.ZodType<
  OrderDate$Outbound,
  z.ZodTypeDef,
  OrderDate
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OrderDate$ {
  /** @deprecated use `OrderDate$inboundSchema` instead. */
  export const inboundSchema = OrderDate$inboundSchema;
  /** @deprecated use `OrderDate$outboundSchema` instead. */
  export const outboundSchema = OrderDate$outboundSchema;
  /** @deprecated use `OrderDate$Outbound` instead. */
  export type Outbound = OrderDate$Outbound;
}

/** @internal */
export const OrderRejectedReason$inboundSchema: z.ZodType<
  OrderRejectedReasonOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OrderRejectedReason),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OrderRejectedReason$outboundSchema: z.ZodType<
  OrderRejectedReasonOpen,
  z.ZodTypeDef,
  OrderRejectedReasonOpen
> = z.union([
  z.nativeEnum(OrderRejectedReason),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OrderRejectedReason$ {
  /** @deprecated use `OrderRejectedReason$inboundSchema` instead. */
  export const inboundSchema = OrderRejectedReason$inboundSchema;
  /** @deprecated use `OrderRejectedReason$outboundSchema` instead. */
  export const outboundSchema = OrderRejectedReason$outboundSchema;
}

/** @internal */
export const OrderStatus$inboundSchema: z.ZodType<
  OrderStatusOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OrderStatus),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OrderStatus$outboundSchema: z.ZodType<
  OrderStatusOpen,
  z.ZodTypeDef,
  OrderStatusOpen
> = z.union([
  z.nativeEnum(OrderStatus),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OrderStatus$ {
  /** @deprecated use `OrderStatus$inboundSchema` instead. */
  export const inboundSchema = OrderStatus$inboundSchema;
  /** @deprecated use `OrderStatus$outboundSchema` instead. */
  export const outboundSchema = OrderStatus$outboundSchema;
}

/** @internal */
export const OrderOrderType$inboundSchema: z.ZodType<
  OrderOrderTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OrderOrderType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OrderOrderType$outboundSchema: z.ZodType<
  OrderOrderTypeOpen,
  z.ZodTypeDef,
  OrderOrderTypeOpen
> = z.union([
  z.nativeEnum(OrderOrderType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OrderOrderType$ {
  /** @deprecated use `OrderOrderType$inboundSchema` instead. */
  export const inboundSchema = OrderOrderType$inboundSchema;
  /** @deprecated use `OrderOrderType$outboundSchema` instead. */
  export const outboundSchema = OrderOrderType$outboundSchema;
}

/** @internal */
export const OrderPrevailingMarketPrice$inboundSchema: z.ZodType<
  OrderPrevailingMarketPrice,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type OrderPrevailingMarketPrice$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const OrderPrevailingMarketPrice$outboundSchema: z.ZodType<
  OrderPrevailingMarketPrice$Outbound,
  z.ZodTypeDef,
  OrderPrevailingMarketPrice
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OrderPrevailingMarketPrice$ {
  /** @deprecated use `OrderPrevailingMarketPrice$inboundSchema` instead. */
  export const inboundSchema = OrderPrevailingMarketPrice$inboundSchema;
  /** @deprecated use `OrderPrevailingMarketPrice$outboundSchema` instead. */
  export const outboundSchema = OrderPrevailingMarketPrice$outboundSchema;
  /** @deprecated use `OrderPrevailingMarketPrice$Outbound` instead. */
  export type Outbound = OrderPrevailingMarketPrice$Outbound;
}

/** @internal */
export const OrderQuantity$inboundSchema: z.ZodType<
  OrderQuantity,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type OrderQuantity$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const OrderQuantity$outboundSchema: z.ZodType<
  OrderQuantity$Outbound,
  z.ZodTypeDef,
  OrderQuantity
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OrderQuantity$ {
  /** @deprecated use `OrderQuantity$inboundSchema` instead. */
  export const inboundSchema = OrderQuantity$inboundSchema;
  /** @deprecated use `OrderQuantity$outboundSchema` instead. */
  export const outboundSchema = OrderQuantity$outboundSchema;
  /** @deprecated use `OrderQuantity$Outbound` instead. */
  export type Outbound = OrderQuantity$Outbound;
}

/** @internal */
export const OrderRightsOfAccumulationAmount$inboundSchema: z.ZodType<
  OrderRightsOfAccumulationAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type OrderRightsOfAccumulationAmount$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const OrderRightsOfAccumulationAmount$outboundSchema: z.ZodType<
  OrderRightsOfAccumulationAmount$Outbound,
  z.ZodTypeDef,
  OrderRightsOfAccumulationAmount
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OrderRightsOfAccumulationAmount$ {
  /** @deprecated use `OrderRightsOfAccumulationAmount$inboundSchema` instead. */
  export const inboundSchema = OrderRightsOfAccumulationAmount$inboundSchema;
  /** @deprecated use `OrderRightsOfAccumulationAmount$outboundSchema` instead. */
  export const outboundSchema = OrderRightsOfAccumulationAmount$outboundSchema;
  /** @deprecated use `OrderRightsOfAccumulationAmount$Outbound` instead. */
  export type Outbound = OrderRightsOfAccumulationAmount$Outbound;
}

/** @internal */
export const RightsOfAccumulation$inboundSchema: z.ZodType<
  RightsOfAccumulation,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.nullable(
    z.lazy(() => OrderRightsOfAccumulationAmount$inboundSchema),
  ).optional(),
});

/** @internal */
export type RightsOfAccumulation$Outbound = {
  amount?: OrderRightsOfAccumulationAmount$Outbound | null | undefined;
};

/** @internal */
export const RightsOfAccumulation$outboundSchema: z.ZodType<
  RightsOfAccumulation$Outbound,
  z.ZodTypeDef,
  RightsOfAccumulation
> = z.object({
  amount: z.nullable(
    z.lazy(() => OrderRightsOfAccumulationAmount$outboundSchema),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RightsOfAccumulation$ {
  /** @deprecated use `RightsOfAccumulation$inboundSchema` instead. */
  export const inboundSchema = RightsOfAccumulation$inboundSchema;
  /** @deprecated use `RightsOfAccumulation$outboundSchema` instead. */
  export const outboundSchema = RightsOfAccumulation$outboundSchema;
  /** @deprecated use `RightsOfAccumulation$Outbound` instead. */
  export type Outbound = RightsOfAccumulation$Outbound;
}

/** @internal */
export const OrderSide$inboundSchema: z.ZodType<
  OrderSideOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OrderSide),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OrderSide$outboundSchema: z.ZodType<
  OrderSideOpen,
  z.ZodTypeDef,
  OrderSideOpen
> = z.union([
  z.nativeEnum(OrderSide),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OrderSide$ {
  /** @deprecated use `OrderSide$inboundSchema` instead. */
  export const inboundSchema = OrderSide$inboundSchema;
  /** @deprecated use `OrderSide$outboundSchema` instead. */
  export const outboundSchema = OrderSide$outboundSchema;
}

/** @internal */
export const OrderSpecialReportingInstructions$inboundSchema: z.ZodType<
  OrderSpecialReportingInstructionsOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OrderSpecialReportingInstructions),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OrderSpecialReportingInstructions$outboundSchema: z.ZodType<
  OrderSpecialReportingInstructionsOpen,
  z.ZodTypeDef,
  OrderSpecialReportingInstructionsOpen
> = z.union([
  z.nativeEnum(OrderSpecialReportingInstructions),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OrderSpecialReportingInstructions$ {
  /** @deprecated use `OrderSpecialReportingInstructions$inboundSchema` instead. */
  export const inboundSchema = OrderSpecialReportingInstructions$inboundSchema;
  /** @deprecated use `OrderSpecialReportingInstructions$outboundSchema` instead. */
  export const outboundSchema =
    OrderSpecialReportingInstructions$outboundSchema;
}

/** @internal */
export const OrderStopPricePrice$inboundSchema: z.ZodType<
  OrderStopPricePrice,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type OrderStopPricePrice$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const OrderStopPricePrice$outboundSchema: z.ZodType<
  OrderStopPricePrice$Outbound,
  z.ZodTypeDef,
  OrderStopPricePrice
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OrderStopPricePrice$ {
  /** @deprecated use `OrderStopPricePrice$inboundSchema` instead. */
  export const inboundSchema = OrderStopPricePrice$inboundSchema;
  /** @deprecated use `OrderStopPricePrice$outboundSchema` instead. */
  export const outboundSchema = OrderStopPricePrice$outboundSchema;
  /** @deprecated use `OrderStopPricePrice$Outbound` instead. */
  export type Outbound = OrderStopPricePrice$Outbound;
}

/** @internal */
export const OrderStopPriceType$inboundSchema: z.ZodType<
  OrderStopPriceTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OrderStopPriceType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OrderStopPriceType$outboundSchema: z.ZodType<
  OrderStopPriceTypeOpen,
  z.ZodTypeDef,
  OrderStopPriceTypeOpen
> = z.union([
  z.nativeEnum(OrderStopPriceType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OrderStopPriceType$ {
  /** @deprecated use `OrderStopPriceType$inboundSchema` instead. */
  export const inboundSchema = OrderStopPriceType$inboundSchema;
  /** @deprecated use `OrderStopPriceType$outboundSchema` instead. */
  export const outboundSchema = OrderStopPriceType$outboundSchema;
}

/** @internal */
export const StopPrice$inboundSchema: z.ZodType<
  StopPrice,
  z.ZodTypeDef,
  unknown
> = z.object({
  price: z.nullable(z.lazy(() => OrderStopPricePrice$inboundSchema)).optional(),
  type: OrderStopPriceType$inboundSchema.optional(),
});

/** @internal */
export type StopPrice$Outbound = {
  price?: OrderStopPricePrice$Outbound | null | undefined;
  type?: string | undefined;
};

/** @internal */
export const StopPrice$outboundSchema: z.ZodType<
  StopPrice$Outbound,
  z.ZodTypeDef,
  StopPrice
> = z.object({
  price: z.nullable(z.lazy(() => OrderStopPricePrice$outboundSchema))
    .optional(),
  type: OrderStopPriceType$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StopPrice$ {
  /** @deprecated use `StopPrice$inboundSchema` instead. */
  export const inboundSchema = StopPrice$inboundSchema;
  /** @deprecated use `StopPrice$outboundSchema` instead. */
  export const outboundSchema = StopPrice$outboundSchema;
  /** @deprecated use `StopPrice$Outbound` instead. */
  export type Outbound = StopPrice$Outbound;
}

/** @internal */
export const OrderTimeInForce$inboundSchema: z.ZodType<
  OrderTimeInForceOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OrderTimeInForce),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OrderTimeInForce$outboundSchema: z.ZodType<
  OrderTimeInForceOpen,
  z.ZodTypeDef,
  OrderTimeInForceOpen
> = z.union([
  z.nativeEnum(OrderTimeInForce),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OrderTimeInForce$ {
  /** @deprecated use `OrderTimeInForce$inboundSchema` instead. */
  export const inboundSchema = OrderTimeInForce$inboundSchema;
  /** @deprecated use `OrderTimeInForce$outboundSchema` instead. */
  export const outboundSchema = OrderTimeInForce$outboundSchema;
}

/** @internal */
export const Order$inboundSchema: z.ZodType<Order, z.ZodTypeDef, unknown> = z
  .object({
    account_id: z.string().optional(),
    asset_id: z.string().optional(),
    asset_type: OrderAssetType$inboundSchema.optional(),
    average_prices: z.array(ExecutedPrice$inboundSchema).optional(),
    broker_capacity: OrderBrokerCapacity$inboundSchema.optional(),
    cancel_reason: z.string().optional(),
    cancel_rejected_reason: CancelRejectedReason$inboundSchema.optional(),
    client_order_id: z.string().optional(),
    client_received_time: z.nullable(
      z.string().datetime({ offset: true }).transform(v => new Date(v)),
    ).optional(),
    commission: z.nullable(z.lazy(() => OrderCommission$inboundSchema))
      .optional(),
    create_time: z.nullable(
      z.string().datetime({ offset: true }).transform(v => new Date(v)),
    ).optional(),
    cumulative_notional_value: z.nullable(
      z.lazy(() => CumulativeNotionalValue$inboundSchema),
    ).optional(),
    currency_code: z.string().optional(),
    executions: z.array(Executions$inboundSchema).optional(),
    fees: z.array(Fee$inboundSchema).optional(),
    filled_quantity: z.nullable(z.lazy(() => FilledQuantity$inboundSchema))
      .optional(),
    identifier: z.string().optional(),
    identifier_issuing_region_code: z.string().optional(),
    identifier_type: OrderIdentifierType$inboundSchema.optional(),
    last_update_time: z.nullable(
      z.string().datetime({ offset: true }).transform(v => new Date(v)),
    ).optional(),
    letter_of_intent: z.nullable(z.lazy(() => LetterOfIntent$inboundSchema))
      .optional(),
    limit_price: z.nullable(z.lazy(() => LimitPrice$inboundSchema)).optional(),
    max_sell_quantity: z.nullable(z.lazy(() => MaxSellQuantity$inboundSchema))
      .optional(),
    name: z.string().optional(),
    notional_value: z.nullable(z.lazy(() => NotionalValue$inboundSchema))
      .optional(),
    order_date: z.nullable(z.lazy(() => OrderDate$inboundSchema)).optional(),
    order_id: z.string().optional(),
    order_rejected_reason: OrderRejectedReason$inboundSchema.optional(),
    order_status: OrderStatus$inboundSchema.optional(),
    order_type: OrderOrderType$inboundSchema.optional(),
    prevailing_market_price: z.nullable(
      z.lazy(() => OrderPrevailingMarketPrice$inboundSchema),
    ).optional(),
    quantity: z.nullable(z.lazy(() => OrderQuantity$inboundSchema)).optional(),
    rights_of_accumulation: z.nullable(
      z.lazy(() => RightsOfAccumulation$inboundSchema),
    ).optional(),
    side: OrderSide$inboundSchema.optional(),
    special_reporting_instructions: z.array(
      OrderSpecialReportingInstructions$inboundSchema,
    ).optional(),
    stop_price: z.nullable(z.lazy(() => StopPrice$inboundSchema)).optional(),
    time_in_force: OrderTimeInForce$inboundSchema.optional(),
  }).transform((v) => {
    return remap$(v, {
      "account_id": "accountId",
      "asset_id": "assetId",
      "asset_type": "assetType",
      "average_prices": "averagePrices",
      "broker_capacity": "brokerCapacity",
      "cancel_reason": "cancelReason",
      "cancel_rejected_reason": "cancelRejectedReason",
      "client_order_id": "clientOrderId",
      "client_received_time": "clientReceivedTime",
      "create_time": "createTime",
      "cumulative_notional_value": "cumulativeNotionalValue",
      "currency_code": "currencyCode",
      "filled_quantity": "filledQuantity",
      "identifier_issuing_region_code": "identifierIssuingRegionCode",
      "identifier_type": "identifierType",
      "last_update_time": "lastUpdateTime",
      "letter_of_intent": "letterOfIntent",
      "limit_price": "limitPrice",
      "max_sell_quantity": "maxSellQuantity",
      "notional_value": "notionalValue",
      "order_date": "orderDate",
      "order_id": "orderId",
      "order_rejected_reason": "orderRejectedReason",
      "order_status": "orderStatus",
      "order_type": "orderType",
      "prevailing_market_price": "prevailingMarketPrice",
      "rights_of_accumulation": "rightsOfAccumulation",
      "special_reporting_instructions": "specialReportingInstructions",
      "stop_price": "stopPrice",
      "time_in_force": "timeInForce",
    });
  });

/** @internal */
export type Order$Outbound = {
  account_id?: string | undefined;
  asset_id?: string | undefined;
  asset_type?: string | undefined;
  average_prices?: Array<ExecutedPrice$Outbound> | undefined;
  broker_capacity?: string | undefined;
  cancel_reason?: string | undefined;
  cancel_rejected_reason?: string | undefined;
  client_order_id?: string | undefined;
  client_received_time?: string | null | undefined;
  commission?: OrderCommission$Outbound | null | undefined;
  create_time?: string | null | undefined;
  cumulative_notional_value?:
    | CumulativeNotionalValue$Outbound
    | null
    | undefined;
  currency_code?: string | undefined;
  executions?: Array<Executions$Outbound> | undefined;
  fees?: Array<Fee$Outbound> | undefined;
  filled_quantity?: FilledQuantity$Outbound | null | undefined;
  identifier?: string | undefined;
  identifier_issuing_region_code?: string | undefined;
  identifier_type?: string | undefined;
  last_update_time?: string | null | undefined;
  letter_of_intent?: LetterOfIntent$Outbound | null | undefined;
  limit_price?: LimitPrice$Outbound | null | undefined;
  max_sell_quantity?: MaxSellQuantity$Outbound | null | undefined;
  name?: string | undefined;
  notional_value?: NotionalValue$Outbound | null | undefined;
  order_date?: OrderDate$Outbound | null | undefined;
  order_id?: string | undefined;
  order_rejected_reason?: string | undefined;
  order_status?: string | undefined;
  order_type?: string | undefined;
  prevailing_market_price?:
    | OrderPrevailingMarketPrice$Outbound
    | null
    | undefined;
  quantity?: OrderQuantity$Outbound | null | undefined;
  rights_of_accumulation?: RightsOfAccumulation$Outbound | null | undefined;
  side?: string | undefined;
  special_reporting_instructions?: Array<string> | undefined;
  stop_price?: StopPrice$Outbound | null | undefined;
  time_in_force?: string | undefined;
};

/** @internal */
export const Order$outboundSchema: z.ZodType<
  Order$Outbound,
  z.ZodTypeDef,
  Order
> = z.object({
  accountId: z.string().optional(),
  assetId: z.string().optional(),
  assetType: OrderAssetType$outboundSchema.optional(),
  averagePrices: z.array(ExecutedPrice$outboundSchema).optional(),
  brokerCapacity: OrderBrokerCapacity$outboundSchema.optional(),
  cancelReason: z.string().optional(),
  cancelRejectedReason: CancelRejectedReason$outboundSchema.optional(),
  clientOrderId: z.string().optional(),
  clientReceivedTime: z.nullable(z.date().transform(v => v.toISOString()))
    .optional(),
  commission: z.nullable(z.lazy(() => OrderCommission$outboundSchema))
    .optional(),
  createTime: z.nullable(z.date().transform(v => v.toISOString())).optional(),
  cumulativeNotionalValue: z.nullable(
    z.lazy(() => CumulativeNotionalValue$outboundSchema),
  ).optional(),
  currencyCode: z.string().optional(),
  executions: z.array(Executions$outboundSchema).optional(),
  fees: z.array(Fee$outboundSchema).optional(),
  filledQuantity: z.nullable(z.lazy(() => FilledQuantity$outboundSchema))
    .optional(),
  identifier: z.string().optional(),
  identifierIssuingRegionCode: z.string().optional(),
  identifierType: OrderIdentifierType$outboundSchema.optional(),
  lastUpdateTime: z.nullable(z.date().transform(v => v.toISOString()))
    .optional(),
  letterOfIntent: z.nullable(z.lazy(() => LetterOfIntent$outboundSchema))
    .optional(),
  limitPrice: z.nullable(z.lazy(() => LimitPrice$outboundSchema)).optional(),
  maxSellQuantity: z.nullable(z.lazy(() => MaxSellQuantity$outboundSchema))
    .optional(),
  name: z.string().optional(),
  notionalValue: z.nullable(z.lazy(() => NotionalValue$outboundSchema))
    .optional(),
  orderDate: z.nullable(z.lazy(() => OrderDate$outboundSchema)).optional(),
  orderId: z.string().optional(),
  orderRejectedReason: OrderRejectedReason$outboundSchema.optional(),
  orderStatus: OrderStatus$outboundSchema.optional(),
  orderType: OrderOrderType$outboundSchema.optional(),
  prevailingMarketPrice: z.nullable(
    z.lazy(() => OrderPrevailingMarketPrice$outboundSchema),
  ).optional(),
  quantity: z.nullable(z.lazy(() => OrderQuantity$outboundSchema)).optional(),
  rightsOfAccumulation: z.nullable(
    z.lazy(() => RightsOfAccumulation$outboundSchema),
  ).optional(),
  side: OrderSide$outboundSchema.optional(),
  specialReportingInstructions: z.array(
    OrderSpecialReportingInstructions$outboundSchema,
  ).optional(),
  stopPrice: z.nullable(z.lazy(() => StopPrice$outboundSchema)).optional(),
  timeInForce: OrderTimeInForce$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    accountId: "account_id",
    assetId: "asset_id",
    assetType: "asset_type",
    averagePrices: "average_prices",
    brokerCapacity: "broker_capacity",
    cancelReason: "cancel_reason",
    cancelRejectedReason: "cancel_rejected_reason",
    clientOrderId: "client_order_id",
    clientReceivedTime: "client_received_time",
    createTime: "create_time",
    cumulativeNotionalValue: "cumulative_notional_value",
    currencyCode: "currency_code",
    filledQuantity: "filled_quantity",
    identifierIssuingRegionCode: "identifier_issuing_region_code",
    identifierType: "identifier_type",
    lastUpdateTime: "last_update_time",
    letterOfIntent: "letter_of_intent",
    limitPrice: "limit_price",
    maxSellQuantity: "max_sell_quantity",
    notionalValue: "notional_value",
    orderDate: "order_date",
    orderId: "order_id",
    orderRejectedReason: "order_rejected_reason",
    orderStatus: "order_status",
    orderType: "order_type",
    prevailingMarketPrice: "prevailing_market_price",
    rightsOfAccumulation: "rights_of_accumulation",
    specialReportingInstructions: "special_reporting_instructions",
    stopPrice: "stop_price",
    timeInForce: "time_in_force",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Order$ {
  /** @deprecated use `Order$inboundSchema` instead. */
  export const inboundSchema = Order$inboundSchema;
  /** @deprecated use `Order$outboundSchema` instead. */
  export const outboundSchema = Order$outboundSchema;
  /** @deprecated use `Order$Outbound` instead. */
  export type Outbound = Order$Outbound;
}
